<?xml version="1.0" encoding="utf-8"?>
<nugget name="ZMOCKUP_LOADER">
 <DEVC DEVCLASS="ZMOCKUP_LOADER" CTEXT="Mockup loader for unit tests" LANGUAGE="E" MASTERLANG="E" KORRFLAG="X" PDEVCLASS="ZSBS" DLVUNIT="HOME" NAMESPACE="/0CUST/" CREATED_BY="USER1" CREATED_ON="20151031" CHANGED_BY="USER1" CHANGED_ON="20151031" PROJECT_GUID="00000000000000000000000000000000"/>
 <CLAS CLSNAME="ZCL_MOCKUP_LOADER" VERSION="1" LANGU="E" DESCRIPT="Mockup loader" CATEGORY="00" EXPOSURE="0" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" WITH_UNIT_TESTS="X" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk">
  <types CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="TT_STRING" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " TYPTYPE="4" SRCROW1="43 " SRCCOLUMN1="4 " SRCROW2="43 " SRCCOLUMN2="33 " TYPESRC_LENG="0 " TYPESRC="tt_string type table of string
"/>
  <types CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="TY_STORE" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="2 " TYPTYPE="4" SRCROW1="45 " SRCCOLUMN1="4 " SRCROW2="49 " SRCCOLUMN2="18 " TYPESRC_LENG="0 " TYPESRC="begin of ty_store,
      name    type char40,
      tabkey  type abap_compname,
      data    type ref to data,
    end of ty_store
"/>
  <types CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="TT_STORE" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="3 " TYPTYPE="4" SRCROW1="51 " SRCCOLUMN1="4 " SRCROW2="51 " SRCCOLUMN2="48 " TYPESRC_LENG="0 " TYPESRC="tt_store type table of ty_store with key name
"/>
  <types CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="TY_FILTER" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="4 " TYPTYPE="4" SRCROW1="53 " SRCCOLUMN1="4 " SRCROW2="57 " SRCCOLUMN2="19 " TYPESRC_LENG="0 " TYPESRC="begin of ty_filter,
      name  type string,
      range type ref to data,
      type  type char1,
    end of ty_filter
"/>
  <types CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="TT_FILTER" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="5 " TYPTYPE="4" SRCROW1="59 " SRCCOLUMN1="4 " SRCROW2="59 " SRCCOLUMN2="59 " TYPESRC_LENG="0 " TYPESRC="tt_filter type standard table of ty_filter with key name
"/>
  <types CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="TY_WHERE" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="6 " TYPTYPE="4" SRCROW1="61 " SRCCOLUMN1="4 " SRCROW2="64 " SRCCOLUMN2="18 " TYPESRC_LENG="0 " TYPESRC="begin of ty_where,
      name  type string,
      range type ref to data,
    end of ty_where
"/>
  <types CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="TT_WHERE" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="7 " TYPTYPE="4" SRCROW1="66 " SRCCOLUMN1="4 " SRCROW2="66 " SRCCOLUMN2="57 " TYPESRC_LENG="0 " TYPESRC="tt_where type standard table of ty_where with key name
"/>
  <localImplementation>* Local definitions and classes</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <localTestClasses>*/--------------------------------------------------------------------------------\
*| This file is part of Mockup loader                                             |
*|                                                                                |
*| The MIT License (MIT)                                                          |
*|                                                                                |
*| Copyright (c) 2015 SBCG Team (www.sbcg.com.ua), Alexander Tsybulsky            |
*|                                                                                |
*| Permission is hereby granted, free of charge, to any person obtaining a copy   |
*| of this software and associated documentation files (the &quot;Software&quot;), to deal  |
*| in the Software without restriction, including without limitation the rights   |
*| to use, copy, modify, merge, publish, distribute, sublicense, and/or sell      |
*| copies of the Software, and to permit persons to whom the Software is          |
*| furnished to do so, subject to the following conditions:                       |
*|                                                                                |
*| The above copyright notice and this permission notice shall be included in all |
*| copies or substantial portions of the Software.                                |
*|                                                                                |
*| THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR     |
*| IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,       |
*| FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE    |
*| AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER         |
*| LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,  |
*| OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  |
*| SOFTWARE.                                                                      |
*\--------------------------------------------------------------------------------/
*/--------------------------------------------------------------------------------\
*| CONTRIBUTORS                                                                   |
*|--------------------------------------------------------------------------------|
*| Leading developers : Alexander Tsybulsky (atsybulsky@sbcg.com.ua)              |
*|                      Svetlana Shlapak    (sshlapak@sbcg.com.ua)                |
*| Testing and ideas:   Bohdan Petruschak   (b.petrushchak@sbcg.com.ua)           |
*|--------------------------------------------------------------------------------|
*| project homepage: https://github.com/sbcgua/mockup_loader                      |
*\--------------------------------------------------------------------------------/

**********************************************************************
* MACRO
**********************************************************************
  define test_parse.
    clear dummy.
    read table lo_struc_descr-&gt;components into ls_component with key name = &apos;&amp;1&apos;.
    call method o-&gt;parse_field
      exporting
        is_component = ls_component
        i_data       = &amp;2
      importing
        e_field      = dummy-&amp;1.
  end-of-definition.

  define test_parse_positive.
    test_parse &amp;1 &amp;2.
    assert_equals( act = dummy-&amp;1 exp = &amp;3 msg = &apos;Parse field positive:&apos; &amp;&amp; &amp;2 ).
  end-of-definition.

  define test_parse_negative.
    clear lo_ex.
    try.
      test_parse &amp;1 &amp;2.
    catch zcx_mockup_loader_error into lo_ex.
    endtry.

    assert_not_initial( act = lo_ex msg = &apos;Parse field negative:&apos; &amp;&amp; &amp;2 ).
    assert_equals( exp = &apos;PF&apos; act = lo_ex-&gt;code ).
  end-of-definition.

  define append_dummy.
    e_dummy_struc-tdate    = &amp;1.
    e_dummy_struc-tchar    = &amp;2.
    e_dummy_struc-tstring  = &amp;3.
    e_dummy_struc-tdecimal = &amp;4.
    e_dummy_struc-tnumber  = &amp;5.
    if i_strict = abap_true.
      e_dummy_struc-traw     = &amp;6.
      e_dummy_struc-tinteger = &amp;7.
      e_dummy_struc-talpha   = &amp;8.
    endif.
    append e_dummy_struc to e_dummy_tab.
  end-of-definition.

  define add_range.
    r_&amp;1-sign   = &amp;2.
    r_&amp;1-option = &amp;3.
    r_&amp;1-low    = &amp;4.
    append r_&amp;1 to l_where-t&amp;1.
  end-of-definition.

  define assert_excode.
    assert_not_initial( act = lo_ex ).
    assert_equals( exp = &amp;1 act = lo_ex-&gt;code ).
  end-of-definition.


**********************************************************************
* Test Class definition
**********************************************************************

class lcl_test_mockup_loader definition for testing
  duration short
  inheriting from cl_aunit_assert  risk level harmless.

* ================
  public section.

    types:
      begin of ty_dummy,
        mandt    type mandt,
        tdate    type datum,
        tchar    type veri_c08,
        traw     type veri_x1,
        tstring  type string,
        talpha   type veri_alpha,
        tdecimal type veri_cur13,
        tnumber  type veri_n04,
        tinteger type i,
      end of ty_dummy.

    types: tt_dummy type table of ty_dummy with default key.

* ================
  private section.
    constants c_tab  like cl_abap_char_utilities=&gt;horizontal_tab value cl_abap_char_utilities=&gt;horizontal_tab.
    constants c_crlf like cl_abap_char_utilities=&gt;cr_lf value cl_abap_char_utilities=&gt;cr_lf.

    data o type ref to zcl_mockup_loader.  &quot;class under test

    class-methods: class_setup.
    methods: setup.

    methods: read_zip                 for testing.
    methods: integrated_test          for testing.
    methods: source_redirect_test     for testing.
    methods: utf16_encoding           for testing.

    methods: parse_data               for testing.
    methods: parse_field              for testing.
    methods: empty_lines              for testing.
    methods: map_file_structure       for testing.
    methods: range_filtering          for testing.

    methods: store_retrieve           for testing.
    methods: retrieve_types           for testing.
    methods: store_retrieve_with_key  for testing.
    methods: store_retrieve_with_where for testing.
    methods: load_and_store           for testing.
    methods: load_raw                 for testing.
    methods: parse_apply_exit         for testing.

    methods: get_dummy_data importing i_strict       type abap_bool default abap_true
                            exporting e_dummy_struc  type ty_dummy
                                      e_dummy_tab    type tt_dummy
                                      e_dummy_string type string.

    methods: filter_helper  importing i_tab        type tt_dummy
                                      i_filter     type zcl_mockup_loader=&gt;tt_filter
                            returning value(e_tab) type tt_dummy.

endclass.       &quot;lcl_test_mockup_loader

* Friends
class zcl_mockup_loader definition local friends lcl_test_mockup_loader.

**********************************************************************
* Implementation
**********************************************************************

class lcl_test_mockup_loader implementation.

**********************************************************************
* Setup methods
**********************************************************************
  method class_setup.
    data l_type_tmp type char4.

    get parameter id &apos;ZMOCKUP_LOADER_STYPE&apos; field l_type_tmp.
    if l_type_tmp is not initial.
      fail( quit = class
            msg  = &apos;Load source is redirected, please reset with ZMOCKUP_LOADER_SWITCH_SOURCE before running the test&apos; ). &quot;#EC NOTEXT
    endif.

    zcl_mockup_loader=&gt;class_set_source( i_type = &apos;MIME&apos; i_path = &apos;ZMOCKUP_LOADER_UNIT_TEST&apos; ).
    zcl_mockup_loader=&gt;class_set_params( i_amt_format = &apos;&apos; i_encoding = &apos;4110&apos; ). &quot; fmt = default, enc = utf-8
  endmethod.       &quot;class_setup

  method setup.
    data lo_ex type ref to zcx_mockup_loader_error.

    try.
      o = zcl_mockup_loader=&gt;get_instance( ).
    catch zcx_mockup_loader_error into lo_ex.
      fail( lo_ex-&gt;get_text( ) ).
    endtry.
  endmethod.       &quot;setup

**********************************************************************
* Dummy data generation
**********************************************************************
  method get_dummy_data.
    data l_string type string.

    if i_strict = abap_true.
      l_string = &apos;MANDT\tTDATE\tTCHAR\tTRAW\tTSTRING\tTALPHA\tTDECIMAL\tTNUMBER\tTINTEGER\n&apos;
              &amp;&amp; &apos;\t01.01.2015\tTrololo1\t8A\tString1\t100000\t1234567,81\t2015\t1111\n&apos;
              &amp;&amp; &apos;\t02.01.2016\tTrololo2\t8B\tString2\t200000\t1234567,82\t2016\t2222\n&apos;
              &amp;&amp; &apos;\t03.01.2016\tTrololo3\t8C\tString3\t300000\t1234567,83\t2015\t3333\n&apos; .
    else.
      l_string = &apos;TDATE\tTSTRING\tTCHAR\tTDECIMAL\tTNUMBER\n&apos;
              &amp;&amp; &apos;01.01.2015\tString1\tTrololo1\t1234567,81\t2015\n&apos;
              &amp;&amp; &apos;02.01.2016\tString2\tTrololo2\t1234567,82\t2016\n&apos;
              &amp;&amp; &apos;03.01.2016\tString3\tTrololo3\t1234567,83\t2015\n&apos; .
    endif.

    replace all occurrences of &apos;\t&apos; in l_string with c_tab.
    replace all occurrences of &apos;\n&apos; in l_string with c_crlf.

    clear e_dummy_tab.

    &quot;             TDATE      TCHAR      TSTRING   TDECIMAL    TNUM TRAW  TINT  TALPHA
    append_dummy &apos;20150101&apos; &apos;Trololo1&apos; &apos;String1&apos; &apos;1234567.81&apos; 2015 &apos;8A&apos;  1111 &apos;0000100000&apos;.
    append_dummy &apos;20160102&apos; &apos;Trololo2&apos; &apos;String2&apos; &apos;1234567.82&apos; 2016 &apos;8B&apos;  2222 &apos;0000200000&apos;.
    append_dummy &apos;20160103&apos; &apos;Trololo3&apos; &apos;String3&apos; &apos;1234567.83&apos; 2015 &apos;8C&apos;  3333 &apos;0000300000&apos;.

    read table e_dummy_tab into e_dummy_struc index 1.
    e_dummy_string = l_string.

  endmethod.       &quot; get_dummy_data

**********************************************************************
* Simple integrated test - most basic usage of the class
**********************************************************************
  method integrated_test.
    data:
          dummy_act      type ty_dummy,
          dummy_exp      type ty_dummy,
          dummy_tab_act  type tt_dummy,
          dummy_tab_exp  type tt_dummy,
          lo_ex          type ref to zcx_mockup_loader_error.

    get_dummy_data( importing e_dummy_struc = dummy_exp
                              e_dummy_tab   = dummy_tab_exp ).

    &quot; Strict ********************************************************
    try.
      call method o-&gt;load_data
        exporting i_obj       = &apos;testdir/testfile_complete&apos;
        importing e_container = dummy_tab_act.

      assert_equals( act = dummy_tab_act exp = dummy_tab_exp ).

      call method o-&gt;load_data
        exporting i_obj       = &apos;testdir/testfile_complete&apos;
        importing e_container = dummy_act.

      assert_equals( act = dummy_act exp = dummy_exp ).

      call method o-&gt;load_data &quot; No MANDT field in file
        exporting i_obj       = &apos;testdir/testfile_no_mandt&apos;
        importing e_container = dummy_tab_act.

      assert_equals( act = dummy_tab_act exp = dummy_tab_exp ).

    catch zcx_mockup_loader_error into lo_ex.
      fail( lo_ex-&gt;get_text( ) ).
    endtry.

    &quot; NOT Strict ****************************************************
    get_dummy_data( exporting i_strict    = abap_false
                    importing e_dummy_tab = dummy_tab_exp ).

    try.
      call method o-&gt;load_data
        exporting i_obj       = &apos;testdir/testfile_no_strict&apos;
                  i_strict    = abap_false
        importing e_container = dummy_tab_act.

      assert_equals( act = dummy_tab_act exp = dummy_tab_exp ).

    catch zcx_mockup_loader_error into lo_ex.
      fail( lo_ex-&gt;get_text( ) ).
    endtry.

    &quot; With where ****************************************************
    get_dummy_data( importing e_dummy_tab   = dummy_tab_exp ).

    read table dummy_tab_exp into dummy_exp with key tnumber = &apos;2016&apos;.
    delete dummy_tab_exp where tnumber &lt;&gt; &apos;2016&apos;.

    try.
      call method o-&gt;load_data
        exporting i_obj       = &apos;testdir/testfile_complete&apos;
                  i_where     = &apos;TNUMBER = 2016&apos;
        importing e_container = dummy_tab_act.

      assert_equals( act = dummy_tab_act exp = dummy_tab_exp ).

      call method o-&gt;load_data
        exporting i_obj       = &apos;testdir/testfile_complete&apos;
                  i_where     = &apos;TNUMBER = 2016&apos;
        importing e_container = dummy_act.

      assert_equals( act = dummy_act exp = dummy_exp ).

    catch zcx_mockup_loader_error into lo_ex.
      fail( lo_ex-&gt;get_text( ) ).
    endtry.

    &quot; No container ***************************************************
    try.
      call method o-&gt;load_data exporting i_obj = &apos;testdir/testfile_complete&apos;.
    catch zcx_mockup_loader_error into lo_ex.
    endtry.
    assert_excode &apos;NC&apos;.

  endmethod.       &quot; integrated_test

**********************************************************************
* Source redirection via SET/GET parameters test
**********************************************************************
  method source_redirect_test.
    data:
          lo_ex      type ref to zcx_mockup_loader_error,
          l_type     type char4,
          l_path     type char40,
          l_path_tmp type char40.

    get parameter id &apos;ZMOCKUP_LOADER_SPATH&apos; field l_path_tmp. &quot; Preserve

    l_type = &apos;MIME&apos;.
    l_path = &apos;ZMOCKUP_LOADER_WRONG_OBJECT&apos;.
    set parameter id &apos;ZMOCKUP_LOADER_STYPE&apos; field l_type.
    set parameter id &apos;ZMOCKUP_LOADER_SPATH&apos; field l_path.
    o-&gt;free_instance( ).

    try.
      o = zcl_mockup_loader=&gt;get_instance( ).
    catch zcx_mockup_loader_error into lo_ex.
    endtry.

    clear l_type.
    set parameter id &apos;ZMOCKUP_LOADER_STYPE&apos; field l_type.
    set parameter id &apos;ZMOCKUP_LOADER_SPATH&apos; field l_path_tmp.
    o-&gt;free_instance( ).

    assert_excode &apos;RE&apos;.

  endmethod.       &quot; source_redirect_test

**********************************************************************
* Check Unicode encoding parsing
**********************************************************************
  method utf16_encoding.
    data:
          dummy_tab_act  type tt_dummy,
          dummy_tab_exp  type tt_dummy,
          lo_ex          type ref to zcx_mockup_loader_error.

    get_dummy_data( importing e_dummy_tab   = dummy_tab_exp ).

    try.
      zcl_mockup_loader=&gt;class_set_params( i_amt_format = &apos;&apos; i_encoding = &apos;4103&apos; ). &quot; UTF16
      call method o-&gt;load_data
        exporting i_obj       = &apos;testdir/testfile_complete_utf16&apos;
        importing e_container = dummy_tab_act.
      zcl_mockup_loader=&gt;class_set_params( i_amt_format = &apos;&apos; i_encoding = &apos;4110&apos; ). &quot; Back to SETUP defaults
    catch zcx_mockup_loader_error into lo_ex.
      zcl_mockup_loader=&gt;class_set_params( i_amt_format = &apos;&apos; i_encoding = &apos;4110&apos; ). &quot; Back to SETUP defaults
      fail( lo_ex-&gt;get_text( ) ).
    endtry.

    assert_equals( act = dummy_tab_act exp = dummy_tab_exp ).

  endmethod. &quot;utf16_encoding

**********************************************************************
* Test of data parser - dummy data is supplied to the tested method
**********************************************************************
  method parse_data.
    data:
          dummy_val      type char40,
          dummy_act      type ty_dummy,
          dummy_tab_act  type tt_dummy,
          dummy_htab     type hashed table of ty_dummy with unique key tdate,
          dummy_stab     type sorted table of ty_dummy with unique key tdate,
          dummy_exp      type ty_dummy,
          dummy_tab_exp  type tt_dummy,
          l_string       type string,
          lo_ex          type ref to zcx_mockup_loader_error.

    &quot; Strict parsing *********************************
    get_dummy_data( importing e_dummy_struc  = dummy_exp
                              e_dummy_tab    = dummy_tab_exp
                              e_dummy_string = l_string ).

    try.
      call method o-&gt;parse_data
        exporting i_rawdata   = l_string
        importing e_container = dummy_act.

      call method o-&gt;parse_data
        exporting i_rawdata   = l_string
        importing e_container = dummy_tab_act.

    catch zcx_mockup_loader_error into lo_ex.
      fail( lo_ex-&gt;get_text( ) ).
    endtry.

    assert_equals( act = dummy_act     exp = dummy_exp ).
    assert_equals( act = dummy_tab_act exp = dummy_tab_exp ).

    &quot; Parse to sorted and hashed tables ***************
    try.
      call method o-&gt;parse_data
        exporting i_rawdata   = l_string
        importing e_container = dummy_stab.
    catch zcx_mockup_loader_error into lo_ex.
      fail( lo_ex-&gt;get_text( ) ).
    endtry.

    assert_equals( act = dummy_stab exp = dummy_tab_exp ).

    try.
      call method o-&gt;parse_data
        exporting i_rawdata   = l_string
        importing e_container = dummy_htab.
    catch zcx_mockup_loader_error into lo_ex.
      fail( lo_ex-&gt;get_text( ) ).
    endtry.

    assert_equals( act = dummy_htab exp = dummy_tab_exp ).

    &quot; NOT STRICT parsing ******************************
    get_dummy_data( exporting i_strict       = abap_false
                    importing e_dummy_tab    = dummy_tab_exp
                              e_dummy_string = l_string ).

    try.
      call method o-&gt;parse_data
        exporting i_rawdata   = l_string
                  i_strict    = &apos;&apos;
        importing e_container = dummy_tab_act.

    catch zcx_mockup_loader_error into lo_ex.
      fail( lo_ex-&gt;get_text( ) ).
    endtry.

    assert_equals( act = dummy_tab_act exp = dummy_tab_exp ).

    &quot; Fields out of bound (more fields than in header) ***
    clear lo_ex.
    get_dummy_data( importing e_dummy_string = l_string ).
    replace first occurrence of &apos;1111&apos; in l_string with &apos;1111&apos; &amp;&amp; c_tab &amp;&amp; &apos;EXCESS_FIELD&apos;.

    try.
      call method o-&gt;parse_data
        exporting i_rawdata   = l_string
        importing e_container = dummy_tab_act.
    catch zcx_mockup_loader_error into lo_ex.
    endtry.
    assert_excode &apos;&gt;H&apos;.

    &quot; Fields out of bound (less fields than in header) ***
    clear lo_ex.
    get_dummy_data( importing e_dummy_string = l_string ).
    replace first occurrence of c_tab &amp;&amp; &apos;1111&apos; in l_string with &apos;&apos;.

    try.
      call method o-&gt;parse_data
        exporting i_rawdata   = l_string
        importing e_container = dummy_tab_act.
    catch zcx_mockup_loader_error into lo_ex.
    endtry.
    assert_excode &apos;&lt;H&apos;.

    &quot; Parse to field (not table or structure) *************
    clear lo_ex.
    get_dummy_data( importing e_dummy_string = l_string ).

    try.
      call method o-&gt;parse_data
        exporting i_rawdata   = l_string
        importing e_container = dummy_val.
    catch zcx_mockup_loader_error into lo_ex.
    endtry.
    assert_excode &apos;DT&apos;.

    &quot; Parse empty file ************************************
    clear lo_ex.
    clear l_string.

    try.
      call method o-&gt;parse_data
        exporting i_rawdata   = l_string
        importing e_container = dummy_tab_act.
    catch zcx_mockup_loader_error into lo_ex.
    endtry.
    assert_excode &apos;NH&apos;.


  endmethod.       &quot;parse_Data

**********************************************************************
* Individual field parsing test
**********************************************************************
  method parse_field.
    data:
          dummy          type ty_dummy,
          lo_struc_descr type ref to cl_abap_structdescr,
          ls_component   type abap_compdescr,
          lo_ex          type ref to zcx_mockup_loader_error.

    lo_struc_descr ?= cl_abap_structdescr=&gt;describe_by_data( dummy ).

    &quot; Positive tests ******************************
    try.
      test_parse_positive TDATE    &apos;01.01.2015&apos;      &apos;20150101&apos;.
      test_parse_positive TCHAR    &apos;ABC&apos;             &apos;ABC&apos;.
      test_parse_positive TSTRING  &apos;The string test&apos; &apos;The string test&apos;.
      test_parse_positive TALPHA   &apos;100000&apos;          &apos;0000100000&apos;.
      test_parse_positive TNUMBER  &apos;2015&apos;            &apos;2015&apos;.
      test_parse_positive TINTEGER &apos;123&apos;             123.
      test_parse_positive TRAW     &apos;8E&apos;              &apos;8E&apos;.
    catch zcx_mockup_loader_error into lo_ex.
      fail( lo_ex-&gt;get_text( ) ).
    endtry.

    &quot; Negative tests ******************************

    test_parse_negative TDATE    &apos;01.012015&apos;.
    test_parse_negative TNUMBER  &apos;20ha&apos;.

    &quot; Decimal converion tests *********************
    try.
      test_parse_positive TDECIMAL &apos;1234.12&apos;         &apos;1234.12&apos;. &quot; Native ABAP format
      test_parse_positive TDECIMAL &apos;-1234.12&apos;        &apos;-1234.12&apos;.&quot; Native ABAP format

      zcl_mockup_loader=&gt;class_set_params( i_amt_format = &apos;&apos; ). &quot; Set defaults
      test_parse_positive TDECIMAL &apos;-1234,12&apos;        &apos;-1234.12&apos;.
      test_parse_positive TDECIMAL &apos;1234,12&apos;         &apos;1234.12&apos;.
      test_parse_positive TDECIMAL &apos;1 234,12&apos;        &apos;1234.12&apos;.
      test_parse_positive TDECIMAL &apos;14,12&apos;           &apos;14.12&apos;.
      test_parse_positive TDECIMAL &apos;1 234 567,12&apos;    &apos;1234567.12&apos;.

      zcl_mockup_loader=&gt;class_set_params( i_amt_format = &apos;.,&apos; ).
      test_parse_positive TDECIMAL &apos;1234,12&apos;         &apos;1234.12&apos;.
      test_parse_positive TDECIMAL &apos;1 234,12&apos;        &apos;1234.12&apos;.
      test_parse_positive TDECIMAL &apos;1.234,12&apos;        &apos;1234.12&apos;.
      test_parse_positive TDECIMAL &apos;14,12&apos;           &apos;14.12&apos;.
      test_parse_positive TDECIMAL &apos;1.234.567,12&apos;    &apos;1234567.12&apos;.

      zcl_mockup_loader=&gt;class_set_params( i_amt_format = &apos;,.&apos; ).
      test_parse_positive TDECIMAL &apos;1234.12&apos;         &apos;1234.12&apos;.
      test_parse_positive TDECIMAL &apos;1 234.12&apos;        &apos;1234.12&apos;.
      test_parse_positive TDECIMAL &apos;1,234.12&apos;        &apos;1234.12&apos;.
      test_parse_positive TDECIMAL &apos;14.12&apos;           &apos;14.12&apos;.
      test_parse_positive TDECIMAL &apos;1,234,567.12&apos;    &apos;1234567.12&apos;.

    catch zcx_mockup_loader_error into lo_ex.
      fail( lo_ex-&gt;get_text( ) ).
    endtry.

    zcl_mockup_loader=&gt;class_set_params( i_amt_format = &apos;&apos; ). &quot; Set defaults
    test_parse_negative TDECIMAL &apos;1 234.12&apos;.
    test_parse_negative TDECIMAL &apos;1 234_12&apos;.
    test_parse_negative TDECIMAL &apos;1234,123&apos;. &quot; 3 decimal digits into amount which has just 2
    test_parse_negative TDECIMAL &apos;1234,12_&apos;.
    test_parse_negative TDECIMAL &apos;Not-a-number&apos;.
    zcl_mockup_loader=&gt;class_set_params( i_amt_format = &apos;.,&apos; ).
    test_parse_negative TDECIMAL &apos;1 234.12&apos;.
    test_parse_negative TDECIMAL &apos;1,234.12&apos;.
    zcl_mockup_loader=&gt;class_set_params( i_amt_format = &apos;,.&apos; ).
    test_parse_negative TDECIMAL &apos;1 234,12&apos;.
    test_parse_negative TDECIMAL &apos;1.234,12&apos;.

    zcl_mockup_loader=&gt;class_set_params( i_amt_format = &apos;&apos; i_encoding = &apos;4110&apos; ). &quot; Set defaults back


  endmethod.       &quot;parse_Field

**********************************************************************
* ZIP file read test - gets data from SMW0 ZMOCKUP_LOADER_UNIT_TEST
**********************************************************************
  method read_zip.
    data:
          l_str      type string,
          lo_ex      type ref to zcx_mockup_loader_error.

    assert_not_initial( act = lines( o-&gt;o_zip-&gt;files ) ).

    &quot; Positive ***************************************
    try.
      call method o-&gt;read_zip
        exporting i_name    = &apos;testdir/testfile_complete.txt&apos;
        importing e_rawdata = l_str.
    catch zcx_mockup_loader_error into lo_ex.
      fail( lo_ex-&gt;get_text( ) ).
    endtry.
    assert_not_initial( act = l_str ).

    &quot; NEGATIVE - wrong file name **********************
    clear lo_ex.
    try.
      call method o-&gt;read_zip
        exporting i_name    = &apos;testdir/wrong_filename.xyz&apos;
        importing e_rawdata = l_str.
    catch zcx_mockup_loader_error into lo_ex.
    endtry.
    assert_excode &apos;ZF&apos;.

    &quot; NEGATIVE - wrong code page **********************
    clear lo_ex.
    try.
      call method o-&gt;read_zip
        exporting i_name    = &apos;testdir/testfile_complete_utf16.txt&apos;
        importing e_rawdata = l_str.
    catch zcx_mockup_loader_error into lo_ex.
    endtry.
    assert_excode &apos;CP&apos;.

  endmethod.        &quot; read_zip

**********************************************************************
* Identification of empty lines in the text files
**********************************************************************
  method empty_lines.
    data:
          dummy_tab_exp type tt_dummy,
          dummy_tab_act type tt_dummy,
          l_string      type string,
          lo_ex         type ref to zcx_mockup_loader_error.

    get_dummy_data( importing e_dummy_tab    = dummy_tab_exp
                              e_dummy_string = l_string ).

    &quot; Add empty line at the end *****************************
    l_string = l_string &amp;&amp; c_crlf.

    try.
      call method o-&gt;parse_data
        exporting i_rawdata   = l_string
        importing e_container = dummy_tab_act.
    catch zcx_mockup_loader_error into lo_ex.
      fail( lo_ex-&gt;get_text( ) ).
    endtry.

    assert_equals( act = dummy_tab_act exp = dummy_tab_exp ).

    &quot; Add empty line in the middle ***************************
    replace first occurrence of c_crlf in l_string with c_crlf &amp;&amp; c_crlf.
    clear lo_ex.

    try.
      call method o-&gt;parse_data
        exporting i_rawdata   = l_string
        importing e_container = dummy_tab_act.
    catch zcx_mockup_loader_error into lo_ex.
    endtry.
    assert_excode &apos;LE&apos;.

    &quot; Add empty line at the beginning ************************
    l_string = c_crlf &amp;&amp; l_string.
    clear lo_ex.

    try.
      call method o-&gt;parse_data
        exporting i_rawdata   = l_string
        importing e_container = dummy_tab_act.
    catch zcx_mockup_loader_error into lo_ex.
    endtry.
    assert_excode &apos;HE&apos;.

  endmethod.       &quot;empty_lines

**********************************************************************
* Test check of in and out data types
**********************************************************************
  method map_file_structure.
    data:
          dummy_tab_exp type tt_dummy,
          dummy_tab_act type tt_dummy,
          l_string      type string,
          l_string_bak  type string,
          lo_ex         type ref to zcx_mockup_loader_error.

    get_dummy_data( importing e_dummy_tab    = dummy_tab_exp
                              e_dummy_string = l_string_bak ).

    &quot; Duplicate field names *******************************
    clear lo_ex. l_string = l_string_bak.
    replace first occurrence of &apos;TCHAR&apos; in l_string with &apos;TDATE&apos;.

    try. o-&gt;parse_data( exporting i_rawdata   = l_string importing e_container = dummy_tab_act ).
    catch zcx_mockup_loader_error into lo_ex.
    endtry.
    assert_excode &apos;DN&apos;.

    &quot; Empty field names ***********************************
    clear lo_ex. l_string = l_string_bak.
    replace first occurrence of &apos;TCHAR&apos; in l_string with &apos;&apos;.

    try. o-&gt;parse_data( exporting i_rawdata   = l_string importing e_container = dummy_tab_act ).
    catch zcx_mockup_loader_error into lo_ex.
    endtry.
    assert_excode &apos;EN&apos;.

    &quot; Unknown field in text *******************************
    clear lo_ex. l_string = l_string_bak.
    replace first occurrence of &apos;TCHAR&apos; in l_string with &apos;UNKNOWN&apos;.

    try. o-&gt;parse_data( exporting i_rawdata   = l_string importing e_container = dummy_tab_act ).
    catch zcx_mockup_loader_error into lo_ex.
    endtry.
    assert_excode &apos;MC&apos;.

    &quot; More fields than in target structure ****************
    clear lo_ex. l_string = l_string_bak.
    replace first occurrence of &apos;TINTEGER&apos; in l_string with &apos;TINTEGER&apos; &amp;&amp; c_tab &amp;&amp; &apos;EXCESS_FIELD&apos;.

    try. o-&gt;parse_data( exporting i_rawdata   = l_string importing e_container = dummy_tab_act ).
    catch zcx_mockup_loader_error into lo_ex.
    endtry.
    assert_excode &apos;CN&apos;.

    &quot; Empty field at the end ******************************
    clear lo_ex. l_string = l_string_bak.
    replace first occurrence of &apos;TINTEGER&apos; in l_string with &apos;TINTEGER&apos; &amp;&amp; c_tab.

    try. o-&gt;parse_data( exporting i_rawdata   = l_string importing e_container = dummy_tab_act ).
    catch zcx_mockup_loader_error into lo_ex.
    endtry.
    assert_excode &apos;EN&apos;.

    &quot; Empty field at the end of data line ******************
    clear lo_ex. l_string = l_string_bak.
    replace first occurrence of &apos;1111&apos; in l_string with &apos;1111&apos; &amp;&amp; c_tab.

    try. o-&gt;parse_data( exporting i_rawdata   = l_string importing e_container = dummy_tab_act ).
    catch zcx_mockup_loader_error into lo_ex.
    endtry.
    assert_excode &apos;&gt;H&apos;.

  endmethod.       &quot;map_file_structure

**********************************************************************
* STORE tests - basic functionality
**********************************************************************
  method store_retrieve.
    data:
          dummy_exp      type ty_dummy,
          dummy_tab_exp  type tt_dummy,
          dummy_act      type ty_dummy,
          dummy_tab_act  type tt_dummy,
          lo_ex          type ref to zcx_mockup_loader_error.

    get_dummy_data( importing e_dummy_struc = dummy_exp
                              e_dummy_tab   = dummy_tab_exp ).

    &quot; Instance method ********************************
    try.
      o-&gt;store( i_name = &apos;STRUC&apos; i_data = dummy_exp ).
      o-&gt;store( i_name = &apos;TAB&apos;   i_data = dummy_tab_exp ).

      call method o-&gt;_retrieve
        exporting i_name  = &apos;STRUC&apos;
        importing e_data = dummy_act.

      call method o-&gt;_retrieve
        exporting i_name  = &apos;TAB&apos;
        importing e_data = dummy_tab_act.

    catch zcx_mockup_loader_error into lo_ex.
      fail( lo_ex-&gt;get_text( ) ).
    endtry.

    assert_equals( act = dummy_act      exp = dummy_exp ).
    assert_equals( act = dummy_tab_act  exp = dummy_tab_exp ).

    &quot; Instance method - NEGATIVE **********************
    try.
      call method o-&gt;_retrieve
        exporting i_name  = &apos;NOT_EXISTING&apos;
        importing e_data = dummy_act.
    catch zcx_mockup_loader_error into lo_ex.
    endtry.
    assert_excode &apos;NF&apos;.

    &quot; Static method ***********************************
    clear: dummy_act, dummy_tab_act.

    call method zcl_mockup_loader=&gt;retrieve
      exporting i_name  = &apos;STRUC&apos;
      importing e_data = dummy_act
      exceptions others = 4.
    assert_subrc( act = sy-subrc ).

    call method zcl_mockup_loader=&gt;retrieve
      exporting i_name  = &apos;TAB&apos;
      importing e_data = dummy_tab_act
      exceptions others = 4.
    assert_subrc( act = sy-subrc ).

    assert_equals( act = dummy_act      exp = dummy_exp ).
    assert_equals( act = dummy_tab_act  exp = dummy_tab_exp ).

    &quot; Static method - NEGATIVE ************************
    call method zcl_mockup_loader=&gt;retrieve
      exporting i_name  = &apos;NOT_EXISTING&apos;
      importing e_data = dummy_act
      exceptions others = 4.

    assert_subrc(  act = sy-subrc       exp = 4 ).
    assert_equals( act = sy-msgno       exp = 499 ). &quot; SY(499) -&gt; &amp; &amp; &amp; &amp;

    &quot; Purge tests
    try.
      o-&gt;store( i_name = &apos;ANOTHER_STRUC&apos; i_data = dummy_exp ).
    catch zcx_mockup_loader_error into lo_ex.
      fail( lo_ex-&gt;get_text( ) ).
    endtry.

    assert_equals( act = lines( o-&gt;at_store ) exp = 3 ).
    o-&gt;purge( &apos;ANOTHER_STRUC&apos; ).
    assert_equals( act = lines( o-&gt;at_store ) exp = 2 ).
    o-&gt;purge( &apos;*&apos; ).
    assert_equals( act = lines( o-&gt;at_store ) exp = 0 ).

  endmethod.       &quot;store_retrieve

**********************************************************************
* STORE RETRIEVE types checking test
**********************************************************************
  method retrieve_types.
    data:
          lo_ex        type ref to zcx_mockup_loader_error,
          lt_src       type scarr_tab,
          lt_dst_tab   type scarr_tab,
          lt_dst_tt    type table of scarr,
          lt_dst_ts    type sorted table of scarr with unique key carrid,
          l_dst_struc  type scarr,
          lt_dst_diff  type table of sflight.

    append initial line to lt_src.
    try. o-&gt;store( i_name = &apos;DATA&apos; i_data = lt_src ).
    catch zcx_mockup_loader_error into lo_ex.
      fail( lo_ex-&gt;get_text( ) ).
    endtry.

    &quot; Store to different kinds of same table *******************
    try.
      call method o-&gt;_retrieve exporting i_name  = &apos;DATA&apos; importing e_data = lt_dst_tab.
      call method o-&gt;_retrieve exporting i_name  = &apos;DATA&apos; importing e_data = lt_dst_tt.
      call method o-&gt;_retrieve exporting i_name  = &apos;DATA&apos; importing e_data = lt_dst_ts.
    catch zcx_mockup_loader_error into lo_ex.
      fail( lo_ex-&gt;get_text( ) ).
    endtry.

    &quot; Store to structure ***************************************
    try. call method o-&gt;_retrieve exporting i_name  = &apos;DATA&apos; importing e_data = l_dst_struc.
    catch zcx_mockup_loader_error into lo_ex.
    endtry.
    assert_excode &apos;TT&apos;.

    &quot; Store to table with different structure ******************
    clear lo_ex.
    try. call method o-&gt;_retrieve exporting i_name  = &apos;DATA&apos; importing e_data = lt_dst_diff.
    catch zcx_mockup_loader_error into lo_ex.
    endtry.
    assert_excode &apos;TS&apos;.

  endmethod.       &quot;retrieve_types

**********************************************************************
* STORE RETRIEVE with table key and sieving (filtering)
**********************************************************************
  method store_retrieve_with_key.
    data:
          dummy_exp      type ty_dummy,
          dummy_tab_exp  type tt_dummy,
          dummy_act      type ty_dummy,
          dummy_tab_act  type tt_dummy,
          ls_wrong       type sflight,
          lo_ex          type ref to zcx_mockup_loader_error.

    get_dummy_data( importing e_dummy_struc = dummy_exp
                              e_dummy_tab   = dummy_tab_exp ).

    try. o-&gt;store( i_name = &apos;TAB&apos; i_data = dummy_tab_exp i_tabkey = &apos;TNUMBER&apos; ).
    catch zcx_mockup_loader_error into lo_ex.
      fail( lo_ex-&gt;get_text( ) ).
    endtry.

    delete dummy_tab_exp where tnumber &lt;&gt; &apos;2016&apos;.

    &quot; Positive *****************************************
    try.
      call method o-&gt;_retrieve
        exporting i_name   = &apos;TAB&apos;
                  i_sift   = &apos;2015&apos;
        importing e_data   = dummy_act.

      call method o-&gt;_retrieve
        exporting i_name   = &apos;TAB&apos;
                  i_sift   = &apos;2016&apos;
        importing e_data   = dummy_tab_act.

    catch zcx_mockup_loader_error into lo_ex.
      fail( lo_ex-&gt;get_text( ) ).
    endtry.

    assert_equals( act = dummy_act      exp = dummy_exp ).
    assert_equals( act = dummy_tab_act  exp = dummy_tab_exp ).

    &quot; Retrieve to wrong structure **********************
    clear lo_ex.
    try.
      call method o-&gt;_retrieve
        exporting i_name   = &apos;TAB&apos;
                  i_sift   = &apos;2015&apos;
        importing e_data   = ls_wrong.
    catch zcx_mockup_loader_error into lo_ex.
    endtry.
    assert_excode &apos;TS&apos;.

    &quot; Retrieve - no data selected **********************
    clear lo_ex.
    try.
      call method o-&gt;_retrieve
        exporting i_name   = &apos;TAB&apos;
                  i_sift   = &apos;2000&apos;
        importing e_data   = dummy_tab_act. &quot; Table
    catch zcx_mockup_loader_error into lo_ex.
    endtry.
    assert_excode &apos;04&apos;.

    clear lo_ex.
    try.
      call method o-&gt;_retrieve
        exporting i_name   = &apos;TAB&apos;
                  i_sift   = &apos;2000&apos;
        importing e_data   = dummy_act.    &quot; Structure
    catch zcx_mockup_loader_error into lo_ex.
    endtry.
    assert_excode &apos;04&apos;.

    &quot; Save structure ************************************
    clear lo_ex.
    try. o-&gt;store( i_name = &apos;STRUC&apos; i_data = dummy_exp i_tabkey = &apos;TNUMBER&apos; ).
    catch zcx_mockup_loader_error into lo_ex.
    endtry.
    assert_excode &apos;TO&apos;.

    &quot; Tab key that does not exist in the structure ******
    clear lo_ex.
    try. o-&gt;store( i_name = &apos;TAB&apos; i_data = dummy_tab_exp i_tabkey = &apos;UNDEFINED&apos; ).
    catch zcx_mockup_loader_error into lo_ex.
    endtry.
    assert_excode &apos;FM&apos;.

  endmethod.       &quot;store_retrieve_with_key

**********************************************************************
* LOAD AND STORE at once
**********************************************************************
  method load_and_store.
    data:
          dummy_tab_exp  type tt_dummy,
          dummy_tab_act  type tt_dummy,
          lo_ex          type ref to zcx_mockup_loader_error.

    get_dummy_data( importing e_dummy_tab   = dummy_tab_exp ).

    &quot; Positive test ************************************
    try.
      call method o-&gt;load_and_store
        exporting i_obj       = &apos;testdir/testfile_complete&apos;
                  i_name      = &apos;TAB&apos;
                  i_type      = &apos;LCL_TEST_MOCKUP_LOADER=&gt;TT_DUMMY&apos;.

      call method o-&gt;_retrieve
        exporting i_name   = &apos;TAB&apos;
        importing e_data   = dummy_tab_act.

    catch zcx_mockup_loader_error into lo_ex.
      fail( lo_ex-&gt;get_text( ) ).
    endtry.

    assert_equals( act = dummy_tab_act  exp = dummy_tab_exp ).

    &quot; Negative: type that not exists ********************
    clear lo_ex.
    try.
      call method o-&gt;load_and_store
        exporting i_obj       = &apos;testdir/testfile_complete&apos;
                  i_name      = &apos;TAB&apos;
                  i_type      = &apos;************&apos;.

    catch zcx_mockup_loader_error into lo_ex.
    endtry.
    assert_excode &apos;WT&apos;.

  endmethod.       &quot;load_and_store

**********************************************************************
* RANGE_FILTERING - test build_filter and does_line_fit_filter
**********************************************************************
  method range_filtering.
    data:
          dummy_tab_src  type tt_dummy,
          dummy_tab_exp  type tt_dummy,
          dummy          type ty_dummy,

          l_filter       type zcl_mockup_loader=&gt;tt_filter,
          lo_ex          type ref to zcx_mockup_loader_error,

          lt_tywhere     type zcl_mockup_loader=&gt;tt_where,
          l_tywhere      type zcl_mockup_loader=&gt;ty_where,

          begin of l_where_err1,
            tnumber  type range of veri_n04,
            tdate    type range of datum,
            tother   type tt_dummy,
          end of l_where_err1,

          begin of l_where_err2,
            tnumber  type range of veri_n04,
            tdate    type range of datum,
            tother   type c,
          end of l_where_err2,

          begin of l_where,
            tnumber  type range of veri_n04,
            tdate    type range of datum,
            tother   type range of c,
          end of l_where,

          r_number  like line of l_where-tnumber,
          r_date    like line of l_where-tdate,
          r_other   like line of l_where-tother.

    get_dummy_data( importing e_dummy_tab = dummy_tab_src ).

    &quot; Negative tests --------------------------------------------------------------------

    &quot; Component is not a range table
    try.  o-&gt;build_filter( exporting i_where = l_where_err1 importing e_filter = l_filter ).
    catch zcx_mockup_loader_error into lo_ex.
    endtry.
    assert_excode &apos;WS&apos;.

    &quot; Component is not a table
    try.  o-&gt;build_filter( exporting i_where = l_where_err2 importing e_filter = l_filter ).
    catch zcx_mockup_loader_error into lo_ex.
    endtry.
    assert_excode &apos;WS&apos;.

    &quot; Unexpected types of filters
    l_tywhere-name = &apos;TNUMBER&apos;.
    get reference of l_where into l_tywhere-range.
    try.  o-&gt;build_filter( exporting i_where = l_tywhere importing e_filter = l_filter ).
    catch zcx_mockup_loader_error into lo_ex.
    endtry.
    assert_excode &apos;CE&apos;.

    &quot; Filter is not range
    l_tywhere-name = &apos;TNUMBER&apos;.
    get reference of dummy_tab_exp into l_tywhere-range.
    try.  o-&gt;build_filter( exporting i_where = l_tywhere importing e_filter = l_filter ).
    catch zcx_mockup_loader_error into lo_ex.
    endtry.
    assert_excode &apos;RT&apos;.

    &quot; Filter is not range + TABLE
    l_tywhere-name = &apos;TNUMBER&apos;.
    get reference of dummy_tab_exp into l_tywhere-range.
    append l_tywhere to lt_tywhere.
    try.  o-&gt;build_filter( exporting i_where = lt_tywhere importing e_filter = l_filter ).
    catch zcx_mockup_loader_error into lo_ex.
    endtry.
    clear lt_tywhere.
    assert_excode &apos;RT&apos;.

    &quot; Wrong type of table
    try.  o-&gt;build_filter( exporting i_where = dummy_tab_exp importing e_filter = l_filter ).
    catch zcx_mockup_loader_error into lo_ex.
    endtry.
    assert_excode &apos;WT&apos;.

    &quot; Parameter is an unsupported type
    try.  o-&gt;build_filter( exporting i_where = lo_ex importing e_filter = l_filter ).
    catch zcx_mockup_loader_error into lo_ex.
    endtry.
    assert_excode &apos;UT&apos;.

    &quot; parameter is incorrect string pattern
    try.  o-&gt;build_filter( exporting i_where = &apos;TNUMBER??&apos; importing e_filter = l_filter ).
    catch zcx_mockup_loader_error into lo_ex.
    endtry.
    assert_excode &apos;SP&apos;.


    &quot; Positive test RANGE STRUCTURE -----------------------------------------------------
    dummy_tab_exp[] = dummy_tab_src[].
    delete dummy_tab_exp where tnumber &lt;&gt; &apos;2015&apos; or tdate &lt; &apos;20160101&apos;.

    add_range number &apos;I&apos; &apos;EQ&apos; &apos;2015&apos;.
    add_range date   &apos;I&apos; &apos;GE&apos; &apos;20160101&apos;.
    add_range other  &apos;I&apos; &apos;GE&apos; &apos;A&apos;.

    try.
      o-&gt;build_filter( exporting i_where = l_where importing e_filter = l_filter ).
    catch zcx_mockup_loader_error into lo_ex.
      fail( lo_ex-&gt;get_text( ) ).
    endtry.

    assert_equals( act = filter_helper( i_tab = dummy_tab_src i_filter = l_filter )
                   exp = dummy_tab_exp ).

    &quot; Positive test TY_WHERE TABLE --------------------------------------------------
    &quot; REUSE dummy_tab_exp and ranges from above
    l_tywhere-name = &apos;TNUMBER&apos;.
    get reference of l_where-tnumber into l_tywhere-range.
    append l_tywhere to lt_tywhere.

    l_tywhere-name = &apos;TDATE&apos;.
    get reference of l_where-tdate into l_tywhere-range.
    append l_tywhere to lt_tywhere.

    try .
      o-&gt;build_filter( exporting i_where = lt_tywhere importing e_filter = l_filter ).
    catch zcx_mockup_loader_error into lo_ex.
      fail( lo_ex-&gt;get_text( ) ).
    endtry.

    assert_equals( act = filter_helper( i_tab = dummy_tab_src i_filter = l_filter )
                   exp = dummy_tab_exp ).

    &quot; Positive test STRING --------------------------------------------------------------
    dummy_tab_exp[] = dummy_tab_src[].
    delete dummy_tab_exp where tnumber &lt;&gt; &apos;2015&apos;.

    try .
      o-&gt;build_filter( exporting i_where = &apos;TNUMBER = 2015&apos; importing e_filter = l_filter ).
    catch zcx_mockup_loader_error into lo_ex.
      fail( lo_ex-&gt;get_text( ) ).
    endtry.

    assert_equals( act = filter_helper( i_tab = dummy_tab_src i_filter = l_filter )
                   exp = dummy_tab_exp ).

    &quot; Positive test TY_WHERE STRUCTURE --------------------------------------------------
    &quot; REUSE dummy_tab_exp and ranges from above
    l_tywhere-name = &apos;TNUMBER&apos;.
    get reference of l_where-tnumber into l_tywhere-range.

    try .
      o-&gt;build_filter( exporting i_where = l_tywhere importing e_filter = l_filter ).
    catch zcx_mockup_loader_error into lo_ex.
      fail( lo_ex-&gt;get_text( ) ).
    endtry.

    assert_equals( act = filter_helper( i_tab = dummy_tab_src i_filter = l_filter )
                   exp = dummy_tab_exp ).

  endmethod.       &quot;range_filtering

  method filter_helper.
    data dummy type ty_dummy.
    loop at i_tab into dummy.
      if o-&gt;does_line_fit_filter( i_line = dummy i_filter = i_filter ) = abap_true.
        append dummy to e_tab.
      endif.
    endloop.
  endmethod.       &quot; filter_helper

**********************************************************************
* LOAD_RAW - test load only method e.g. for XMLs
**********************************************************************
  method load_raw.
    data:
          lo_exr     type ref to cx_root,
          lo_ex      type ref to zcx_mockup_loader_error,
          l_str_exp  type string,
          l_xstr_act type xstring,
          l_str_act  type string,
          lo_conv    type ref to cl_abap_conv_in_ce.

    l_str_exp = &apos;&lt;?xml version=&quot;1.0&quot;?&gt;&lt;mytag&gt;mydata&lt;/mytag&gt;&apos;.

    try. &quot; .XML
      lo_conv = cl_abap_conv_in_ce=&gt;create( encoding = &apos;4110&apos; ).
      o-&gt;load_raw( exporting i_obj = &apos;testdir/test_raw&apos;
                             i_ext = &apos;.xml&apos;
                   importing e_content = l_xstr_act ).
      lo_conv-&gt;convert( exporting input = l_xstr_act importing data = l_str_act ).
    catch cx_root into lo_exr.
      fail( lo_ex-&gt;get_text( ) ).
    endtry.

    assert_equals( act = l_str_act exp = l_str_exp ).

    try. &quot; .TXT
      o-&gt;load_raw( exporting i_obj = &apos;testdir/test_raw&apos;
                   importing e_content = l_xstr_act ).
      lo_conv-&gt;convert( exporting input = l_xstr_act importing data = l_str_act ).
    catch cx_root into lo_exr.
      fail( lo_ex-&gt;get_text( ) ).
    endtry.

    assert_equals( act = l_str_act exp = l_str_exp ).

    try. &quot; No container
      o-&gt;load_raw( exporting i_obj = &apos;testdir/test_raw&apos; ).
    catch zcx_mockup_loader_error into lo_ex.
    endtry.
    assert_excode &apos;NC&apos;.

  endmethod. &quot;load_raw

**********************************************************************
* PARSE_APPLY_EXIT - apply exit test
**********************************************************************
  method parse_apply_exit.
    data:
          l_dummy  type ty_dummy,
          lo_ex    type ref to zcx_mockup_loader_error.

    try .
      o-&gt;parse_apply_exit( exporting i_convexit = &apos;ALPHA&apos;
                                     i_data     = &apos;123&apos;
                           importing e_field    = l_dummy-talpha ).
    catch zcx_mockup_loader_error into lo_ex.
      fail( lo_ex-&gt;get_text( ) ).
    endtry.

    assert_equals( act = l_dummy-talpha exp = &apos;0000000123&apos; ).

    &quot; Check wrong exit
    clear lo_ex.
    try .
      o-&gt;parse_apply_exit( exporting i_convexit = &apos;NONAME&apos;
                                     i_data     = &apos;123&apos;
                           importing e_field    = l_dummy-talpha ).
    catch zcx_mockup_loader_error into lo_ex.
    endtry.
    assert_excode &apos;EM&apos;.

  endmethod. &quot;parse_apply_exit

**********************************************************************
* STORE_RETRIEVE_WITH_WHERE - New logic with i_where in store
**********************************************************************
  method store_retrieve_with_where.
    data:
          dummy_exp      type ty_dummy,
          dummy_tab_exp  type tt_dummy,
          dummy_act      type ty_dummy,
          lo_ex          type ref to zcx_mockup_loader_error.

    get_dummy_data( importing e_dummy_tab   = dummy_tab_exp ).
    read table dummy_tab_exp into dummy_exp with key tnumber = &apos;2016&apos;.

    &quot; POSITIVE - use i_where
    try .
      o-&gt;store( i_name = &apos;STRUC&apos; i_data = dummy_exp ).
      o-&gt;store( i_name = &apos;TAB&apos;   i_data = dummy_tab_exp ).

      o-&gt;_retrieve( exporting i_name = &apos;TAB&apos; i_where = &apos;TNUMBER=2016&apos;
                    importing e_data = dummy_act ).
    catch zcx_mockup_loader_error into lo_ex.
      fail( lo_ex-&gt;get_text( ) ).
    endtry.
    assert_equals( act = dummy_act exp = dummy_exp ).

    &quot; NEGATIVE - Pass both filter simultaneously
    clear lo_ex.
    try .
      o-&gt;_retrieve( exporting i_name = &apos;TAB&apos; i_sift = &apos;X&apos; i_where = &apos;Y&apos;
                    importing e_data = dummy_act ).
    catch zcx_mockup_loader_error into lo_ex.
    endtry.
    assert_excode &apos;WP&apos;.

    &quot; NEGATIVE - Store without tab key
    clear lo_ex.
    try .
      o-&gt;_retrieve( exporting i_name = &apos;TAB&apos; i_sift = &apos;X&apos;
                    importing e_data = dummy_act ).
    catch zcx_mockup_loader_error into lo_ex.
    endtry.
    assert_excode &apos;FM&apos;.

    &quot; NEGATIVE - Filter tables only
    clear lo_ex.
    try .
      o-&gt;_retrieve( exporting i_name = &apos;STRUC&apos; i_where = &apos;TNUMBER=2016&apos;
                    importing e_data = dummy_act ).
    catch zcx_mockup_loader_error into lo_ex.
    endtry.
    assert_excode &apos;TO&apos;.


  endmethod. &quot;store_retrieve_with_where

endclass.       &quot;lcl_Test_Mockup_Loader</localTestClasses>
  <typeUsage CLSNAME="ZCL_MOCKUP_LOADER" TYPEGROUP="ABAP" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <forwardDeclaration>ABAP</forwardDeclaration>
  <typeClasDef CLSNAME="ZCL_MOCKUP_LOADER" TYPEGROUP="CL_ABAP_ZIP" VERSION="1" TPUTYPE="1" IMPLICIT="X"/>
  <attribute CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="AT_STORE" VERSION="1" LANGU="E" DESCRIPT="Store table" EXPOSURE="0" STATE="1" EDITORDER="3 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TT_STORE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="GO_INSTANCE" VERSION="1" LANGU="E" DESCRIPT="Mockup loader" EXPOSURE="0" STATE="1" EDITORDER="1 " ATTDECLTYP="1" ATTEXPVIRT="0" TYPTYPE="3" TYPE="ZCL_MOCKUP_LOADER" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="G_AMT_FORMAT" VERSION="1" LANGU="E" DESCRIPT="Decimal separators (thousands+decimal)" EXPOSURE="0" STATE="1" EDITORDER="6 " ATTDECLTYP="1" ATTEXPVIRT="0" TYPTYPE="1" TYPE="CHAR2" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="G_ENCODING" VERSION="1" LANGU="E" DESCRIPT="Text file encoding" EXPOSURE="0" STATE="1" EDITORDER="7 " ATTDECLTYP="1" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ABAP_ENCODING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="G_MOCKUP_SRC_PATH" VERSION="1" LANGU="E" DESCRIPT="Mockup load path/key" EXPOSURE="0" STATE="1" EDITORDER="4 " ATTDECLTYP="1" ATTEXPVIRT="0" TYPTYPE="1" TYPE="STRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="G_MOCKUP_SRC_TYPE" VERSION="1" LANGU="E" DESCRIPT="Mockup load source type" EXPOSURE="0" STATE="1" EDITORDER="5 " ATTDECLTYP="1" ATTEXPVIRT="0" TYPTYPE="1" TYPE="CHAR4" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="O_ZIP" VERSION="1" LANGU="E" DESCRIPT="Zip Utility" EXPOSURE="0" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="3" TYPE="CL_ABAP_ZIP" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <method CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="BUILD_FILTER" VERSION="1" LANGU="E" DESCRIPT="Validate filter parameter and prepare filter structure" EXPOSURE="0" STATE="1" EDITORDER="7 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="BUILD_FILTER" SCONAME="I_WHERE" VERSION="1" LANGU="E" DESCRIPT="Filter conditions" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <parameter CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="BUILD_FILTER" SCONAME="E_FILTER" VERSION="1" LANGU="E" DESCRIPT="Filter hash" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="TT_FILTER"/>
   <exception CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="BUILD_FILTER" SCONAME="ZCX_MOCKUP_LOADER_ERROR" VERSION="1" LANGU="E" DESCRIPT="Exception class for mockup loader" MTDTYPE="0" EDITORDER="1 "/>
   <source>method BUILD_FILTER.
  data dy_templ      type ref to cl_abap_tabledescr.
  data dy_type       type ref to cl_abap_typedescr.
  data dy_struc      type ref to cl_abap_structdescr.
  data dy_table      type ref to cl_abap_tabledescr.

  data l_filter      type ty_filter.
  data l_where       type ty_where.
  data lt_filter     type tt_filter.
  data lt_components type cl_abap_structdescr=&gt;component_table.
  data l_component   like line of lt_components.

  field-symbols &lt;ftable&gt; type any table.
  field-symbols &lt;cond&gt;   type string.

  clear     e_filter.
  dy_type   = cl_abap_typedescr=&gt;describe_by_data( i_where ).
  dy_templ ?= cl_abap_typedescr=&gt;describe_by_name( &apos;SVER_TABLE_TYPE_VERI_RANGE&apos; ).

  try.
    case dy_type-&gt;type_kind.
    when cl_abap_typedescr=&gt;typekind_table. &quot; Table -&gt; expect tt_where
      dy_table ?= dy_type.
      dy_struc ?= dy_table-&gt;get_table_line_type( ).
      if not dy_struc-&gt;absolute_name cs &apos;\CLASS=ZCL_MOCKUP_LOADER\TYPE=TY_WHERE&apos;.
        zcx_mockup_loader_error=&gt;raise( msg = |I_WHERE table must be of TT_WHERE type| code = &apos;WT&apos; ).   &quot;#EC NOTEXT
      endif.

      assign i_where to &lt;ftable&gt;.
      loop at &lt;ftable&gt; into l_where.
        l_filter-name  = l_where-name.
        l_filter-range = l_where-range.
        l_filter-type  = &apos;R&apos;. &quot; Range
        dy_table ?= cl_abap_typedescr=&gt;describe_by_data_ref( l_filter-range ). &quot; Assume table, cast_error otherwise
        if dy_table-&gt;key ne dy_templ-&gt;key. &quot; Not range ?
          zcx_mockup_loader_error=&gt;raise( msg = |I_WHERE-RANGE must be a range table| code = &apos;RT&apos; ).   &quot;#EC NOTEXT
        endif.
        append l_filter to lt_filter.
      endloop.

    when cl_abap_typedescr=&gt;typekind_struct2.
      dy_struc      ?= dy_type.

      if dy_struc-&gt;absolute_name = &apos;\CLASS=ZCL_MOCKUP_LOADER\TYPE=TY_WHERE&apos;.
        l_where        = i_where.
        l_filter-name  = l_where-name.
        l_filter-range = l_where-range.
        l_filter-type  = &apos;R&apos;. &quot; Range
        dy_table ?= cl_abap_typedescr=&gt;describe_by_data_ref( l_filter-range ). &quot; Assume table, cast_error otherwise
        if dy_table-&gt;key ne dy_templ-&gt;key. &quot; Not range ?
          zcx_mockup_loader_error=&gt;raise( msg = |I_WHERE-RANGE must be a range table| code = &apos;RT&apos; ).   &quot;#EC NOTEXT
        endif.
        append l_filter to lt_filter.

      else.
        lt_components  = dy_struc-&gt;get_components( ).
        loop at lt_components into l_component.
          if l_component-type-&gt;kind &lt;&gt; cl_abap_typedescr=&gt;kind_table.
            zcx_mockup_loader_error=&gt;raise( msg = |I_WHERE must be a structure of ranges or TY_WHERE| code = &apos;WS&apos; ).   &quot;#EC NOTEXT
          endif.

          dy_table ?= l_component-type.
          if dy_table-&gt;key ne dy_templ-&gt;key. &quot; Not range-like structure ?
            zcx_mockup_loader_error=&gt;raise( msg = |I_WHERE must be a structure of ranges or TY_WHERE| code = &apos;WS&apos; ).   &quot;#EC NOTEXT
          endif.

          l_filter-name = l_component-name.
          l_filter-type = &apos;R&apos;. &quot; Range
          assign component l_component-name of structure i_where to &lt;ftable&gt;.
          get reference of &lt;ftable&gt; into l_filter-range.
          append l_filter to lt_filter.
        endloop.
      endif.

    when cl_abap_typedescr=&gt;typekind_char or cl_abap_typedescr=&gt;typekind_string.
      l_filter-type = &apos;S&apos;. &quot; String
      create data l_filter-range type string.
      assign l_filter-range-&gt;* to &lt;cond&gt;.

      split i_where at &apos;=&apos; into l_filter-name &lt;cond&gt;.
      shift l_filter-name right deleting trailing space.
      shift l_filter-name left  deleting leading space.
      shift &lt;cond&gt;        right deleting trailing space.
      shift &lt;cond&gt;        left  deleting leading space.

      if l_filter-name is initial or &lt;cond&gt; is initial.
        zcx_mockup_loader_error=&gt;raise( msg = |Incorrect I_WHERE string pattern| code = &apos;SP&apos; ).   &quot;#EC NOTEXT
      endif.

      append l_filter to lt_filter.

    when others.
      zcx_mockup_loader_error=&gt;raise( msg = |Unsupported type { dy_type-&gt;absolute_name } of I_WHERE| code = &apos;UT&apos; ).   &quot;#EC NOTEXT
    endcase.

  catch cx_sy_move_cast_error.
    zcx_mockup_loader_error=&gt;raise( msg = |CX_SY_MOVE_CAST_ERROR @BUILD_FILTER()| code = &apos;CE&apos; ).   &quot;#EC NOTEXT
  endtry.

  e_filter = lt_filter.

endmethod.</source>
  </method>
  <method CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="CLASS_CONSTRUCTOR" VERSION="1" LANGU="E" DESCRIPT="Class constructor" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <source>method class_constructor.
  class_set_source( i_type = &apos;MIME&apos; i_path = &apos;&apos; ). &quot; Defaults
  class_set_params( i_amt_format = &apos;&apos; i_encoding = &apos;4103&apos; ). &quot; Defaults, UTF16
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="CLASS_SET_PARAMS" VERSION="1" LANGU="E" DESCRIPT="Set parameters (e.g. decimal separator)" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="CLASS_SET_PARAMS" SCONAME="I_AMT_FORMAT" VERSION="1" LANGU="E" DESCRIPT="Decimal separators format" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CHAR2" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="CLASS_SET_PARAMS" SCONAME="I_ENCODING" VERSION="1" LANGU="E" DESCRIPT="Text file encoding" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_ENCODING" PAROPTIONL="X"/>
   <source>method CLASS_SET_PARAMS.
  if i_amt_format is initial or g_amt_format+1(1) is initial. &quot; Empty param or decimal separator
    g_amt_format = &apos; ,&apos;. &quot; Defaults
  else.
    g_amt_format = i_amt_format.
  endif.

  if i_encoding is initial.
    g_encoding = &apos;4103&apos;. &quot; UTF16
  else.
    g_encoding = i_encoding.
  endif.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="CLASS_SET_SOURCE" VERSION="1" LANGU="E" DESCRIPT="Set alternative load path" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="CLASS_SET_SOURCE" SCONAME="I_PATH" VERSION="1" LANGU="E" DESCRIPT="Load path" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <parameter CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="CLASS_SET_SOURCE" SCONAME="I_TYPE" VERSION="1" LANGU="E" DESCRIPT="Load source" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CHAR4"/>
   <source>method class_set_source.
  if i_type = &apos;MIME&apos; or i_type = &apos;FILE&apos;. &quot;TODO some more sophisticated error handling
    g_mockup_src_type = i_type.
    g_mockup_src_path = i_path.
  endif.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="DOES_LINE_FIT_FILTER" VERSION="1" LANGU="E" DESCRIPT="Check if data line fit filters" EXPOSURE="0" STATE="1" EDITORDER="8 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="DOES_LINE_FIT_FILTER" SCONAME="I_LINE" VERSION="1" LANGU="E" DESCRIPT="Data line" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <parameter CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="DOES_LINE_FIT_FILTER" SCONAME="I_FILTER" VERSION="1" LANGU="E" DESCRIPT="Filter hash" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TT_FILTER"/>
   <parameter CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="DOES_LINE_FIT_FILTER" SCONAME="R_YESNO" VERSION="1" LANGU="E" DESCRIPT="Boolean result" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ABAP_BOOL"/>
   <source>method DOES_LINE_FIT_FILTER.
  data l_filter         type ty_filter.
  field-symbols &lt;field&gt; type any.
  field-symbols &lt;range&gt; type any table.
  field-symbols &lt;cond&gt;  type string.

  r_yesno = abap_true.

  loop at i_filter into l_filter.
    assign component l_filter-name of structure i_line to &lt;field&gt;.
    check &lt;field&gt; is assigned. &quot; Just skip irrelevant ranges

    if l_filter-type = &apos;R&apos;.               &quot; Range
      assign l_filter-range-&gt;* to &lt;range&gt;.
    else.                                 &quot; String
      assign l_filter-range-&gt;* to &lt;cond&gt;.
    endif.

    if &lt;range&gt; is assigned and not &lt;field&gt; in &lt;range&gt;
    or &lt;cond&gt;  is assigned and not &lt;field&gt; = &lt;cond&gt;. &quot; cx_sy_conversion_error does not catch that :(
      r_yesno = abap_false.
      exit.
    endif.

    unassign: &lt;field&gt;, &lt;range&gt;, &lt;cond&gt;.
  endloop.

endmethod.</source>
  </method>
  <method CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="FREE_INSTANCE" VERSION="1" LANGU="E" DESCRIPT="Free singleton instance" EXPOSURE="2" STATE="1" EDITORDER="5 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <source>method free_instance.
  if go_instance is not initial.
    free go_instance.
  endif.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="GET_INSTANCE" VERSION="1" LANGU="E" DESCRIPT="Get instance" EXPOSURE="2" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="GET_INSTANCE" SCONAME="RO_INSTANCE" VERSION="1" LANGU="E" DESCRIPT="Mockup loader" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_MOCKUP_LOADER"/>
   <exception CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="GET_INSTANCE" SCONAME="ZCX_MOCKUP_LOADER_ERROR" VERSION="1" LANGU="E" MTDTYPE="0" EDITORDER="1 "/>
   <source>method get_instance.

  if go_instance is initial.
    create object go_instance.
    go_instance-&gt;initialize( ).
  endif.

  ro_instance = go_instance.

endmethod.</source>
  </method>
  <method CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="INITIALIZE" VERSION="1" LANGU="E" DESCRIPT="Initialize" EXPOSURE="0" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <exception CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="INITIALIZE" SCONAME="ZCX_MOCKUP_LOADER_ERROR" VERSION="1" LANGU="E" MTDTYPE="0" EDITORDER="1 "/>
   <source>method INITIALIZE.
  data: l_key       type wwwdatatab,
        l_xstring   type xstring,
        l_size      type int4,
        lt_w3mime   type table of w3mime,
        ls_w3mime   type w3mime.

  data:
        l_src_type  type char4,
        l_src_path  type string,
        l_type_tmp  type char4,
        l_path_tmp  type char40.

  &quot; Get re-direction settings from session memory
  get parameter id &apos;ZMOCKUP_LOADER_STYPE&apos; field l_type_tmp.
  get parameter id &apos;ZMOCKUP_LOADER_SPATH&apos; field l_path_tmp.

  if l_type_tmp is not initial and l_path_tmp is not initial.
    l_src_type = l_type_tmp.
    l_src_path = l_path_tmp.
  else.
    l_src_type = g_mockup_src_type.
    l_src_path = g_mockup_src_path.
  endif.

  &quot; Load data
  case l_src_type.
  when &apos;MIME&apos;. &quot; Load from SMW0
    l_key-relid = &apos;MI&apos;.
    l_key-objid = l_src_path.

    call function &apos;WWWDATA_IMPORT&apos;
      exporting
        key    = l_key
      tables
        mime   = lt_w3mime[]
      exceptions
        others = 1.

    if sy-subrc is not initial.
      zcx_mockup_loader_error=&gt;raise( msg = &apos;SMW0 data import error&apos; code = &apos;RE&apos; ).  &quot;#EC NOTEXT
    endif.

    describe table lt_w3mime lines l_size.
    l_size = sy-tleng * sy-tfill.

  when &apos;FILE&apos;. &quot; Load from frontend
    call function &apos;GUI_UPLOAD&apos;
    exporting
      filename   = l_src_path
      filetype   = &apos;BIN&apos;
    importing
      filelength = l_size
    tables
      data_tab   = lt_w3mime
    exceptions
      others = 1.

    if sy-subrc is not initial.
      zcx_mockup_loader_error=&gt;raise( msg = |Cannot upload file: { l_src_path }| code = &apos;RE&apos; ). &quot;#EC NOTEXT
    endif.

  when others.
    if sy-subrc is not initial.
      zcx_mockup_loader_error=&gt;raise( msg = &apos;Wrong source type&apos; code = &apos;WS&apos; ). &quot;#EC NOTEXT
    endif.

  endcase.

  &quot; Convert to XString
  call function &apos;SCMS_BINARY_TO_XSTRING&apos;
    exporting
      input_length = l_size
    importing
      buffer       = l_xstring
    tables
      binary_tab   = lt_w3mime[]
    exceptions
      failed       = 1.

  if sy-subrc is not initial.
    zcx_mockup_loader_error=&gt;raise( &apos;Binary to string error&apos; ). &quot;#EC NOTEXT
  endif.

  &quot; Extract zip
  if o_zip is initial.
    create object o_zip.
  endif.

  o_zip-&gt;load( exporting  zip    = l_xstring
               exceptions others = 4 ).

  if sy-subrc is not initial or lines( o_zip-&gt;files ) = 0.
    zcx_mockup_loader_error=&gt;raise( msg = &apos;ZIP load failed&apos; code = &apos;ZE&apos; ).  &quot;#EC NOTEXT
  endif.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="LOAD_AND_STORE" VERSION="1" LANGU="E" DESCRIPT="Load table from ZIP" EXPOSURE="2" STATE="1" EDITORDER="7 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="LOAD_AND_STORE" SCONAME="I_OBJ" VERSION="1" LANGU="E" DESCRIPT="Object to load" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <parameter CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="LOAD_AND_STORE" SCONAME="I_STRICT" VERSION="1" LANGU="E" DESCRIPT="Strict structure analysis" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_BOOL" PARVALUE="ABAP_TRUE"/>
   <parameter CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="LOAD_AND_STORE" SCONAME="I_NAME" VERSION="1" LANGU="E" DESCRIPT="Store place label" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CHAR40"/>
   <parameter CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="LOAD_AND_STORE" SCONAME="I_TYPE" VERSION="1" LANGU="E" DESCRIPT="Type to load" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CSEQUENCE"/>
   <parameter CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="LOAD_AND_STORE" SCONAME="I_TABKEY" VERSION="1" LANGU="E" DESCRIPT="Table key for filtering" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_COMPNAME" PAROPTIONL="X"/>
   <exception CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="LOAD_AND_STORE" SCONAME="ZCX_MOCKUP_LOADER_ERROR" VERSION="1" LANGU="E" MTDTYPE="0" EDITORDER="1 "/>
   <source>method load_and_store.
  data:
        lo_type  type ref to cl_abap_typedescr,
        lo_dtype type ref to cl_abap_datadescr,
        lr_data  type ref to data.

  field-symbols &lt;data&gt; type data.

  &quot; Create container to load zip data to
  cl_abap_typedescr=&gt;describe_by_name(
    exporting  p_name      = i_type
    receiving  p_descr_ref = lo_type
    exceptions others      = 4 ).

  if sy-subrc is not initial.
    zcx_mockup_loader_error=&gt;raise( msg = |Type { i_type } not found|  code = &apos;WT&apos; ). &quot;#EC NOTEXT
  endif.

  lo_dtype ?= lo_type.

  create data lr_data type handle lo_dtype.
  assign lr_data-&gt;* to &lt;data&gt;.

  &quot; Load from zip and store
  me-&gt;load_data( exporting i_obj       = i_obj
                           i_strict    = i_strict
                 importing e_container = &lt;data&gt; ).

  me-&gt;_store( i_name     = i_name
              i_data_ref = lr_data
              i_tabkey   = i_tabkey ).

endmethod.</source>
  </method>
  <method CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="LOAD_DATA" VERSION="1" LANGU="E" DESCRIPT="Load table from ZIP" EXPOSURE="2" STATE="1" EDITORDER="8 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="LOAD_DATA" SCONAME="I_OBJ" VERSION="1" LANGU="E" DESCRIPT="Object to load" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <parameter CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="LOAD_DATA" SCONAME="I_STRICT" VERSION="1" LANGU="E" DESCRIPT="Strict structure analysis" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_BOOL" PARVALUE="ABAP_TRUE"/>
   <parameter CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="LOAD_DATA" SCONAME="I_WHERE" VERSION="1" LANGU="E" DESCRIPT="Filter conditions" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="LOAD_DATA" SCONAME="E_CONTAINER" VERSION="1" LANGU="E" DESCRIPT="Target container" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <exception CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="LOAD_DATA" SCONAME="ZCX_MOCKUP_LOADER_ERROR" VERSION="1" LANGU="E" MTDTYPE="0" EDITORDER="1 "/>
   <source>method load_data.
  data l_rawdata  type string.

  if e_container is not supplied.
    zcx_mockup_loader_error=&gt;raise( msg = &apos;No container supplied&apos; code = &apos;NC&apos; ). &quot;#EC NOTEXT
  endif.

  me-&gt;read_zip( exporting i_name    = i_obj &amp;&amp; &apos;.txt&apos;
                importing e_rawdata = l_rawdata ).

  me-&gt;parse_data( exporting i_rawdata   = l_rawdata
                            i_strict    = i_strict
                            i_where     = i_where
                  importing e_container = e_container ).

endmethod.</source>
  </method>
  <method CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="LOAD_RAW" VERSION="1" LANGU="E" DESCRIPT="Load structure from ZIP" EXPOSURE="2" STATE="1" EDITORDER="6 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="LOAD_RAW" SCONAME="I_OBJ" VERSION="1" LANGU="E" DESCRIPT="Object to load" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <parameter CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="LOAD_RAW" SCONAME="I_EXT" VERSION="1" LANGU="E" DESCRIPT='File extention instead of &quot;.txt&quot;' CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="LOAD_RAW" SCONAME="E_CONTENT" VERSION="1" LANGU="E" DESCRIPT="Target container" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="XSTRING"/>
   <exception CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="LOAD_RAW" SCONAME="ZCX_MOCKUP_LOADER_ERROR" VERSION="1" LANGU="E" MTDTYPE="0" EDITORDER="1 "/>
   <source>method load_raw.
  data l_filename type string.

  if e_content is not supplied.
    zcx_mockup_loader_error=&gt;raise( msg = &apos;No container supplied&apos; code = &apos;NC&apos; ). &quot;#EC NOTEXT
  endif.

  if i_ext is initial.
    l_filename = i_obj &amp;&amp; &apos;.txt&apos;.
  else.
    l_filename = i_obj &amp;&amp; i_ext.
  endif.

  o_zip-&gt;get( exporting name    = l_filename
              importing content = e_content ).

endmethod.</source>
  </method>
  <method CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="MAP_FILE_STRUCTURE" VERSION="1" LANGU="E" DESCRIPT="Analyse structure" EXPOSURE="0" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="MAP_FILE_STRUCTURE" SCONAME="I_LINE" VERSION="1" LANGU="E" DESCRIPT="Header data line" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <parameter CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="MAP_FILE_STRUCTURE" SCONAME="IO_STRUC_DESCR" VERSION="1" LANGU="E" DESCRIPT="Target structure description" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="CL_ABAP_STRUCTDESCR"/>
   <parameter CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="MAP_FILE_STRUCTURE" SCONAME="I_STRICT" VERSION="1" LANGU="E" DESCRIPT="Strict processing" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_BOOL"/>
   <parameter CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="MAP_FILE_STRUCTURE" SCONAME="ET_MAP" VERSION="1" LANGU="E" DESCRIPT="Field mapping" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="INT4_TABLE"/>
   <exception CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="MAP_FILE_STRUCTURE" SCONAME="ZCX_MOCKUP_LOADER_ERROR" VERSION="1" LANGU="E" MTDTYPE="0" EDITORDER="1 "/>
   <source>method map_file_structure.
  data:
        l_tabcnt     type i,
        l_fieldcnt   type i,
        lt_fields    type tt_string,
        l_field_name type string,
        lt_dupcheck  type tt_string,
        l_struc_name type string.

  l_struc_name = io_struc_descr-&gt;get_relative_name( ).
  split i_line at cl_abap_char_utilities=&gt;horizontal_tab into table lt_fields.

  &quot; Check if the line ends with TAB
  find all occurrences of cl_abap_char_utilities=&gt;horizontal_tab in i_line match count l_tabcnt.
  if l_tabcnt = lines( lt_fields ). &quot; Line ends with TAB, last empty field is not added to table, see help for &apos;split&apos;
    zcx_mockup_loader_error=&gt;raise( msg = |Empty field at the end @{ l_struc_name }| code = &apos;EN&apos; ).   &quot;#EC NOTEXT
  endif.

  &quot; Compare number of fields, check structure similarity
  if i_strict = abap_true.
    l_fieldcnt = lines( lt_fields ).

    &quot; MANDT field may be skipped
    read table io_struc_descr-&gt;components with key name = &apos;MANDT&apos; transporting no fields.
    if sy-subrc is initial. &quot; Found in strcuture components
      read table lt_fields with key table_line = &apos;MANDT&apos; transporting no fields.
      if sy-subrc is not initial. &quot; But not found in the file
        add 1 to l_fieldcnt.
      endif.
    endif.

    if l_fieldcnt &lt;&gt; lines( io_struc_descr-&gt;components ).
      zcx_mockup_loader_error=&gt;raise( msg = |Different columns number @{ l_struc_name }| code = &apos;CN&apos; ).   &quot;#EC NOTEXT
    endif.
  endif.

  &quot; Check duplicate field names in incoming structure
  lt_dupcheck[] = lt_fields[].
  sort lt_dupcheck[].
  delete adjacent duplicates from lt_dupcheck[].
  if lines( lt_dupcheck ) &lt;&gt; lines( lt_fields ).
    zcx_mockup_loader_error=&gt;raise( msg = |Duplicate field names found @{ l_struc_name }| code = &apos;DN&apos; ).   &quot;#EC NOTEXT
  endif.

  &quot; Compare columns names and make map
  loop at lt_fields into l_field_name.
    if l_field_name is initial. &quot; Check empty fields
      zcx_mockup_loader_error=&gt;raise( msg = |Empty field name found @{ l_struc_name }| code = &apos;EN&apos; ).   &quot;#EC NOTEXT
    endif.

    read table io_struc_descr-&gt;components with key name = l_field_name transporting no fields.
    if sy-subrc is initial.
      append sy-tabix to et_map.
    else.
      zcx_mockup_loader_error=&gt;raise( msg = |{ l_field_name } not found in structure @{ l_struc_name }| code = &apos;MC&apos; ). &quot;#EC NOTEXT
    endif.
  endloop.

endmethod.                    &quot;analyse_structure</source>
  </method>
  <method CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="PARSE_APPLY_EXIT" VERSION="1" LANGU="E" DESCRIPT="Apply conversion exit" EXPOSURE="0" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="PARSE_APPLY_EXIT" SCONAME="I_DATA" VERSION="1" LANGU="E" DESCRIPT="Text data" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <parameter CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="PARSE_APPLY_EXIT" SCONAME="I_CONVEXIT" VERSION="1" LANGU="E" DESCRIPT="Conversion exit" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <parameter CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="PARSE_APPLY_EXIT" SCONAME="E_FIELD" VERSION="1" LANGU="E" DESCRIPT="Target field" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <exception CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="PARSE_APPLY_EXIT" SCONAME="ZCX_MOCKUP_LOADER_ERROR" VERSION="1" LANGU="E" MTDTYPE="0" EDITORDER="1 "/>
   <source>method parse_apply_exit.
  data l_fmname type rs38l_fnam value &apos;CONVERSION_EXIT_XXXXX_INPUT&apos;.

  replace first occurrence of &apos;XXXXX&apos; in l_fmname with i_convexit.

  call function &apos;FUNCTION_EXISTS&apos;
    exporting
      funcname           = l_fmname
    exceptions
      function_not_exist = 1
      others             = 2.

  if sy-subrc &lt;&gt; 0.
    zcx_mockup_loader_error=&gt;raise( msg = &apos;Conversion exit not found&apos; code = &apos;EM&apos; ). &quot;#EC NOTEXT
  endif.

  call function l_fmname
    exporting  input  = i_data
    importing  output = e_field
    exceptions others = 1.

  if sy-subrc &lt;&gt; 0.
    zcx_mockup_loader_error=&gt;raise( msg = &apos;Conversion exit failed&apos; code = &apos;EF&apos; ). &quot;#EC NOTEXT
  endif.

endmethod.</source>
  </method>
  <method CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="PARSE_DATA" VERSION="1" LANGU="E" DESCRIPT="Parse data structure (temporary)" EXPOSURE="0" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="PARSE_DATA" SCONAME="I_RAWDATA" VERSION="1" LANGU="E" DESCRIPT="Data to parse" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <parameter CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="PARSE_DATA" SCONAME="I_STRICT" VERSION="1" LANGU="E" DESCRIPT="Strict structure analysis" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_BOOL" PARVALUE="ABAP_TRUE"/>
   <parameter CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="PARSE_DATA" SCONAME="I_WHERE" VERSION="1" LANGU="E" DESCRIPT="Filter conditions" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="PARSE_DATA" SCONAME="E_CONTAINER" VERSION="1" LANGU="E" DESCRIPT="Target container" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <exception CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="PARSE_DATA" SCONAME="ZCX_MOCKUP_LOADER_ERROR" VERSION="1" LANGU="E" MTDTYPE="0" EDITORDER="1 "/>
   <source>method parse_data.
  data:
        lt_lines       type table of string,
        ls_line        type string,
        lt_map         type int4_table,
        lt_filter      type tt_filter,

        lo_type_descr  type ref to cl_abap_typedescr,
        lo_table_descr type ref to cl_abap_tabledescr,
        lo_struc_descr type ref to cl_abap_structdescr,
        ref_tab_line   type ref to data.

  field-symbols:
                 &lt;table&gt;      type any table,
                 &lt;container&gt;  type any.

  clear e_container.

  &quot; Identify container type and create temp container
  lo_type_descr = cl_abap_typedescr=&gt;describe_by_data( e_container ).
  case lo_type_descr-&gt;kind.
  when &apos;T&apos;. &quot; Table
    lo_table_descr ?= lo_type_descr.
    lo_struc_descr ?= lo_table_descr-&gt;get_table_line_type( ).
    create data ref_tab_line type handle lo_struc_descr.
    assign ref_tab_line-&gt;* to &lt;container&gt;.
    assign e_container     to &lt;table&gt;.
  when &apos;S&apos;. &quot; Structure
    lo_struc_descr ?= lo_type_descr.
    assign e_container to &lt;container&gt;.
  when others. &quot; Not a table or structure ?
    zcx_mockup_loader_error=&gt;raise( msg = &apos;Table or structure containers only&apos; code = &apos;DT&apos; ). &quot;#EC NOTEXT
  endcase.

  &quot; Build filter hash if supplied
  if i_where is not initial.
    me-&gt;build_filter( exporting i_where  = i_where
                      importing e_filter = lt_filter ).
  endif.

  &quot; Read and process header line
  split i_rawdata at cl_abap_char_utilities=&gt;cr_lf into table lt_lines.
  read table lt_lines into ls_line index 1.
  if sy-subrc &lt;&gt; 0.
    zcx_mockup_loader_error=&gt;raise( msg = &apos;No header line found in the file&apos; code = &apos;NH&apos; ). &quot;#EC NOTEXT
  endif.
  if ls_line is initial.
    zcx_mockup_loader_error=&gt;raise( msg = &apos;Header line is empty&apos;  code = &apos;HE&apos; ). &quot;#EC NOTEXT
  endif.

  delete lt_lines index 1.

  me-&gt;map_file_structure( exporting i_line         = ls_line
                                    io_struc_descr = lo_struc_descr
                                    i_strict       = i_strict
                          importing et_map         = lt_map ).

  &quot; Main data parsing loop
  loop at lt_lines into ls_line.
    if ls_line is initial. &quot; Check empty lines
      check sy-tabix &lt; lines( lt_lines ). &quot; Last line of a file may be empty, others - not
      zcx_mockup_loader_error=&gt;raise( msg = |Empty line { sy-tabix + 1 } cannot be parsed|  code = &apos;LE&apos; ). &quot;#EC NOTEXT
    endif.

    me-&gt;parse_line( exporting i_line         = ls_line
                              io_struc_descr = lo_struc_descr
                              it_map         = lt_map
                              i_index        = sy-tabix + 1
                    importing es_container   = &lt;container&gt; ).

    if does_line_fit_filter( i_line = &lt;container&gt; i_filter = lt_filter ) = abap_true.
      if lo_type_descr-&gt;kind = &apos;S&apos;. &quot; Structure
        exit. &quot; Only first line goes to structure and then exits
      else. &quot; Table
        insert &lt;container&gt; into table &lt;table&gt;.
      endif.
    endif.

  endloop.

endmethod.</source>
  </method>
  <method CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="PARSE_FIELD" VERSION="1" LANGU="E" DESCRIPT="Parse 1 field" EXPOSURE="0" STATE="1" EDITORDER="6 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="PARSE_FIELD" SCONAME="IS_COMPONENT" VERSION="1" LANGU="E" DESCRIPT="Component description" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_COMPDESCR"/>
   <parameter CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="PARSE_FIELD" SCONAME="I_DATA" VERSION="1" LANGU="E" DESCRIPT="Text data" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <parameter CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="PARSE_FIELD" SCONAME="E_FIELD" VERSION="1" LANGU="E" DESCRIPT="Target field" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <exception CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="PARSE_FIELD" SCONAME="ZCX_MOCKUP_LOADER_ERROR" VERSION="1" LANGU="E" MTDTYPE="0" EDITORDER="1 "/>
   <source>method parse_field.
  data:
        l_mask  type string,
        l_tmp   type string,
        l_regex type string.

  case is_component-type_kind.
    when &apos;D&apos;. &quot; Date
      call function &apos;CONVERT_DATE_TO_INTERNAL&apos;
        exporting
          date_external            = i_data
          accept_initial_date      = &apos;X&apos;
        importing  date_internal   = e_field
        exceptions date_external_is_invalid = 4.

    when &apos;C&apos;. &quot; Char + convexits
      describe field e_field edit mask l_mask.
      if l_mask is initial.
        e_field = i_data.
      else.
        shift l_mask left deleting leading &apos;=&apos;.
        me-&gt;parse_apply_exit( exporting i_data     = i_data
                                        i_convexit = l_mask
                              importing e_field    = e_field ).
      endif.

    when &apos;g&apos;. &quot; String
      e_field = i_data.

    when &apos;P&apos;. &quot; Amount
      try .
        e_field = i_data. &quot; Try native format first - xxxx.xx

      catch cx_sy_arithmetic_error cx_sy_conversion_error.
        l_tmp   = i_data.
        l_regex = &apos;^-?\d{1,3}(T\d{3})*(\D\d{1,C})?$&apos;. &quot;#EC NOTEXT
        condense l_tmp no-gaps.
        replace &apos;C&apos; in l_regex with |{ is_component-decimals }|.

        &quot; Validate number
        find first occurrence of g_amt_format+0(1) in l_tmp.
        if sy-subrc is initial. &quot; Found
          replace &apos;T&apos; in l_regex with g_amt_format+0(1).
        else.
          replace &apos;T&apos; in l_regex with &apos;&apos;.
        endif.

        replace &apos;D&apos; in l_regex with g_amt_format+1(1).
        find all occurrences of regex l_regex in l_tmp match count sy-tabix.

        if sy-tabix = 1.
          if not g_amt_format+0(1) is initial.  &quot; Remove thousand separators
            replace all occurrences of g_amt_format+0(1) in l_tmp with &apos;&apos;.
          endif.

          if g_amt_format+1(1) &lt;&gt; &apos;.&apos;.          &quot; Replace decimal separator
            replace g_amt_format+1(1) in l_tmp with &apos;.&apos;.
          endif.

          try. &quot; Try converting again
            clear sy-subrc.
            e_field = l_tmp.
          catch cx_sy_arithmetic_error cx_sy_conversion_error.
            sy-subrc = 4.
          endtry.
        else. &quot; Not matched
          sy-subrc = 4.
        endif.

      endtry.

    when &apos;N&apos; or &apos;I&apos;. &quot; Integer number
      if i_data co &apos;0123456789&apos;.
        e_field = i_data.
      else.
        sy-subrc = 4.
      endif.

    when &apos;X&apos;.        &quot; Raw
      try .
        e_field = i_data.
      catch cx_sy_conversion_no_raw cx_sy_conversion_error.
        sy-subrc = 4.
      endtry.

  endcase.

  if sy-subrc is not initial.
    zcx_mockup_loader_error=&gt;raise( msg = |Field: { is_component-name }| code = &apos;PF&apos; ). &quot;#EC NOTEXT
  endif.

endmethod.</source>
  </method>
  <method CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="PARSE_LINE" VERSION="1" LANGU="E" DESCRIPT="Parse one data line" EXPOSURE="0" STATE="1" EDITORDER="5 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="PARSE_LINE" SCONAME="I_LINE" VERSION="1" LANGU="E" DESCRIPT="Data line" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <parameter CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="PARSE_LINE" SCONAME="IT_MAP" VERSION="1" LANGU="E" DESCRIPT="Fields map" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="INT4_TABLE"/>
   <parameter CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="PARSE_LINE" SCONAME="IO_STRUC_DESCR" VERSION="1" LANGU="E" DESCRIPT="Target structure" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="CL_ABAP_STRUCTDESCR"/>
   <parameter CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="PARSE_LINE" SCONAME="I_INDEX" VERSION="1" LANGU="E" DESCRIPT="Line number" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="INT4"/>
   <parameter CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="PARSE_LINE" SCONAME="ES_CONTAINER" VERSION="1" LANGU="E" DESCRIPT="Target container" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <exception CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="PARSE_LINE" SCONAME="ZCX_MOCKUP_LOADER_ERROR" VERSION="1" LANGU="E" DESCRIPT="Exception class for mockup loader" MTDTYPE="0" EDITORDER="1 "/>
   <source>method parse_line.
  data:
        l_tabcnt       type i,
        lt_fields      type table of string,
        ls_field       type string,
        ls_component   type abap_compdescr,
        l_index        type int4.

  field-symbols &lt;field&gt; type any.

  clear es_container.
  split i_line at cl_abap_char_utilities=&gt;horizontal_tab into table lt_fields.

  &quot; Count TABs, if line ends with TAB last empty field is not added to table, see help for &apos;split&apos;
  find all occurrences of cl_abap_char_utilities=&gt;horizontal_tab in i_line match count l_tabcnt.
  add 1 to l_tabcnt. &quot; Number of fields in the line

  &quot; Check field number is the same as in header
  if l_tabcnt &gt; lines( it_map ).
    zcx_mockup_loader_error=&gt;raise( msg = |More fields than in header @{ i_index }| code = &apos;&gt;H&apos; ). &quot;#EC NOTEXT
  elseif l_tabcnt &lt; lines( it_map ).
    zcx_mockup_loader_error=&gt;raise( msg = |Less fields than in header @{ i_index }| code = &apos;&lt;H&apos; ). &quot;#EC NOTEXT
  endif.

  &quot; Move data to table line
  loop at lt_fields into ls_field.
    read table it_map into l_index index sy-tabix. &quot; Read map

    read table io_struc_descr-&gt;components into ls_component index l_index. &quot; Get component
    if sy-subrc is not initial.
      zcx_mockup_loader_error=&gt;raise( &apos;No component found?!&apos; ). &quot;#EC NOTEXT
    endif.

    check ls_component-name ne &apos;MANDT&apos;. &quot; Skip client fields

    unassign &lt;field&gt;.
    assign component ls_component-name of structure es_container to &lt;field&gt;.
    if &lt;field&gt; is not assigned.
      zcx_mockup_loader_error=&gt;raise( &apos;Field assign failed?!&apos; ). &quot;#EC NOTEXT
    endif.

    me-&gt;parse_field( exporting is_component = ls_component
                               i_data       = ls_field
                     importing e_field      = &lt;field&gt; ).

  endloop.

endmethod.</source>
  </method>
  <method CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="PURGE" VERSION="1" LANGU="E" DESCRIPT="Retrieve data from store" EXPOSURE="2" STATE="1" EDITORDER="9 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="PURGE" SCONAME="I_NAME" VERSION="1" LANGU="E" DESCRIPT="Store item to purge" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CHAR40"/>
   <source>method purge.
  data l_store type ty_store.

  if i_name = &apos;*&apos;. &quot; Delete all
    loop at at_store into l_store.
      free l_store-data.
    endloop.
    clear at_store.

  else.            &quot; Delete specific record
    read table at_store with key name = i_name into l_store.
    if sy-subrc is initial.
      delete at_store index sy-tabix.
      free l_store-data.
    endif.
  endif.

endmethod.</source>
  </method>
  <method CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="READ_ZIP" VERSION="1" LANGU="E" DESCRIPT="Read ZIP file" EXPOSURE="0" STATE="1" EDITORDER="9 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="READ_ZIP" SCONAME="I_NAME" VERSION="1" LANGU="E" DESCRIPT="File name" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <parameter CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="READ_ZIP" SCONAME="E_RAWDATA" VERSION="1" LANGU="E" DESCRIPT="String container" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <exception CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="READ_ZIP" SCONAME="ZCX_MOCKUP_LOADER_ERROR" VERSION="1" LANGU="E" MTDTYPE="0" EDITORDER="1 "/>
   <source>method read_zip.
  data:
        l_xstring type xstring,
        lo_conv   type ref to cl_abap_conv_in_ce,
        l_ex      type ref to cx_root.

  o_zip-&gt;get( exporting  name            = i_name
              importing  content         = l_xstring
              exceptions zip_index_error = 1 ).

  if sy-subrc is not initial.
    zcx_mockup_loader_error=&gt;raise( msg = |Cannot read { i_name }| code = &apos;ZF&apos; ). &quot;#EC NOTEXT
  endif.

  &quot; Remove unicide signatures
  case g_encoding.
    when &apos;4110&apos;. &quot; UTF-8
      shift l_xstring left deleting leading  cl_abap_char_utilities=&gt;byte_order_mark_utf8 in byte mode.
    when &apos;4103&apos;. &quot; UTF-16LE
      shift l_xstring left deleting leading  cl_abap_char_utilities=&gt;byte_order_mark_little in byte mode.
  endcase.

  try.
    lo_conv = cl_abap_conv_in_ce=&gt;create( encoding = g_encoding ).
    lo_conv-&gt;convert( exporting input = l_xstring importing data = e_rawdata ).
  catch cx_root into l_ex.
    zcx_mockup_loader_error=&gt;raise( msg = &apos;Codepage conversion error&apos; code = &apos;CP&apos; ). &quot;#EC NOTEXT
  endtry.

endmethod.</source>
  </method>
  <method CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="RETRIEVE" VERSION="1" LANGU="E" DESCRIPT="Retrieve data from store" EXPOSURE="2" STATE="1" EDITORDER="10 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="RETRIEVE" SCONAME="I_NAME" VERSION="1" LANGU="E" DESCRIPT="Store item" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CHAR40"/>
   <parameter CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="RETRIEVE" SCONAME="I_SIFT" VERSION="1" LANGU="E" DESCRIPT="Filter with tab key" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CLIKE" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="RETRIEVE" SCONAME="I_WHERE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="RETRIEVE" SCONAME="E_DATA" VERSION="1" LANGU="E" DESCRIPT="Target container" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <exception CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="RETRIEVE" SCONAME="RETRIEVE_ERROR" VERSION="1" LANGU="E" DESCRIPT="ZCL_MOCKUP_LOADER-&gt;RETRIEVE() FAILED" MTDTYPE="0" EDITORDER="1 "/>
   <source>method retrieve.
  data lo_ex type ref to zcx_mockup_loader_error.

  try .
    get_instance( )-&gt;_retrieve( exporting i_name  = i_name
                                          i_sift  = i_sift
                                          i_where = i_where
                                importing e_data  = e_data ).

  catch zcx_mockup_loader_error into lo_ex.

    &quot; Switch to non-class exceptions to ensure better code readability
    &quot; and compatibility with substituted select results
    &quot; e.g. zcl_mockup_loader=&gt;retrieve( ... ). if sy_subrc is not initial ...
    cl_message_helper=&gt;set_msg_vars_for_if_t100_msg( text = lo_ex ).
    message id sy-msgid type sy-msgty number sy-msgno
      raising retrieve_error
      with sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.

  endtry.

endmethod.</source>
  </method>
  <method CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="STORE" VERSION="1" LANGU="E" DESCRIPT="Save data to store" EXPOSURE="2" STATE="1" EDITORDER="11 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="STORE" SCONAME="I_NAME" VERSION="1" LANGU="E" DESCRIPT="Store place label" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CHAR40"/>
   <parameter CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="STORE" SCONAME="I_DATA" VERSION="1" LANGU="E" DESCRIPT="Data to store" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <parameter CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="STORE" SCONAME="I_TABKEY" VERSION="1" LANGU="E" DESCRIPT="Table key for filtering" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_COMPNAME" PAROPTIONL="X"/>
   <exception CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="STORE" SCONAME="ZCX_MOCKUP_LOADER_ERROR" VERSION="1" LANGU="E" MTDTYPE="0" EDITORDER="1 "/>
   <source>method store.
  data          lr_data type ref to data.
  field-symbols &lt;data&gt;  type any.

  &quot; Create clone container
  create data lr_data like i_data.
  assign lr_data-&gt;* to &lt;data&gt;.

  &lt;data&gt; = i_data. &quot; Copy data to container

  me-&gt;_store( i_name     = i_name
              i_data_ref = lr_data
              i_tabkey   = i_tabkey ).

endmethod.</source>
  </method>
  <method CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="_RETRIEVE" VERSION="1" LANGU="E" DESCRIPT="Retrieve data from store HELPER" EXPOSURE="0" STATE="1" EDITORDER="11 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="_RETRIEVE" SCONAME="I_NAME" VERSION="1" LANGU="E" DESCRIPT="Character field of length 40" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CHAR40"/>
   <parameter CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="_RETRIEVE" SCONAME="I_SIFT" VERSION="1" LANGU="E" DESCRIPT="Filter with tab key" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CLIKE" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="_RETRIEVE" SCONAME="I_WHERE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="_RETRIEVE" SCONAME="E_DATA" VERSION="1" LANGU="E" DESCRIPT="Place to retrieve store to" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
   <exception CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="_RETRIEVE" SCONAME="ZCX_MOCKUP_LOADER_ERROR" VERSION="1" LANGU="E" MTDTYPE="0" EDITORDER="1 "/>
   <source>method _retrieve.
  data:
        l_store     type ty_store,
        lt_filter   type tt_filter,
        r_data_tab  type ref to data,
        ld_src      type ref to cl_abap_typedescr,
        ld_dst      type ref to cl_abap_typedescr,
        ld_tab      type ref to cl_abap_tabledescr,
        ld_src_line type ref to cl_abap_structdescr,
        ld_dst_line type ref to cl_abap_structdescr.

  field-symbols:
        &lt;line&gt;    type any,
        &lt;tabkey&gt;  type any,
        &lt;src_tab&gt; type any table,
        &lt;tmp_tab&gt; type standard table,
        &lt;data&gt;    type any.

  clear e_data.

  &quot; Validate parameters
  if i_sift is not initial and i_where is not initial.
    zcx_mockup_loader_error=&gt;raise( msg = |Pass just one filter param| code = &apos;WP&apos; ). &quot;#EC NOTEXT
  endif.

  &quot; Find store
  read table at_store with key name = i_name into l_store.
  if sy-subrc is not initial.
    zcx_mockup_loader_error=&gt;raise( msg = |Cannot find store { i_name }| code = &apos;NF&apos; ). &quot;#EC NOTEXT
  endif.

  assign l_store-data-&gt;* to &lt;data&gt;.

  &quot; Build filter
  if i_sift is not initial.
    if l_store-tabkey is initial.
      zcx_mockup_loader_error=&gt;raise( msg = &apos;Tabkey field not found&apos; code = &apos;FM&apos; ). &quot;#EC NOTEXT
    endif.
    build_filter( exporting i_where  = l_store-tabkey &amp;&amp; &apos;=&apos; &amp;&amp; i_sift
                  importing e_filter = lt_filter ).
  elseif i_where is not initial.
    build_filter( exporting i_where  = i_where
                  importing e_filter = lt_filter ).
  endif.

  &quot; Ensure types are the same
  ld_src = cl_abap_typedescr=&gt;describe_by_data( &lt;data&gt; ).
  ld_dst = cl_abap_typedescr=&gt;describe_by_data( e_data ).

  if ld_src-&gt;kind = &apos;T&apos;.
    ld_tab      ?= ld_src.
    ld_src_line ?= ld_tab-&gt;get_table_line_type( ).
  endif.

  &quot; Ensure filter is applied to a table
  if lt_filter is not initial and ld_src-&gt;kind &lt;&gt; &apos;T&apos;.
    zcx_mockup_loader_error=&gt;raise( msg = &apos;Filtering is relevant for tables only&apos; code = &apos;TO&apos; ). &quot;#EC NOTEXT
  endif.

  &quot; If types are not equal try going deeper to table line structure
  if ld_src-&gt;absolute_name ne ld_dst-&gt;absolute_name.
    if ld_src-&gt;kind = &apos;T&apos; and ld_dst-&gt;kind = &apos;T&apos;. &quot; Table =&gt; Table
      ld_tab      ?= ld_dst.
      ld_dst_line ?= ld_tab-&gt;get_table_line_type( ).
    elseif lt_filter is not initial and ld_src-&gt;kind = &apos;T&apos; and ld_dst-&gt;kind = &apos;S&apos;. &quot; Table + filter =&gt; Structure
      ld_dst_line ?= ld_dst.
    else.
      zcx_mockup_loader_error=&gt;raise( msg = |Types differ for store { i_name }| code = &apos;TT&apos; ). &quot;#EC NOTEXT
    endif.

    if ld_src_line-&gt;absolute_name ne ld_dst_line-&gt;absolute_name.
      zcx_mockup_loader_error=&gt;raise( msg = |Types differ for store { i_name }| code = &apos;TS&apos; ). &quot;#EC NOTEXT
    endif.
  endif.

  &quot; Copy or sift (filter with tabkey) values
  if lt_filter is initial.
    e_data = &lt;data&gt;.

  else. &quot; Assuming ld_src-&gt;kind = &apos;T&apos; -&gt; see STORE
    assert ld_dst-&gt;kind ca &apos;ST&apos;.
    assign l_store-data-&gt;* to &lt;src_tab&gt;.

    if ld_dst-&gt;kind = &apos;T&apos;.
      ld_tab = cl_abap_tabledescr=&gt;create( p_line_type  = ld_src_line
                                           p_table_kind = cl_abap_tabledescr=&gt;tablekind_std
                                           p_unique     = abap_false ).

      create data r_data_tab type handle ld_tab.
      assign r_data_tab-&gt;* to &lt;tmp_tab&gt;.
    endif.

    loop at &lt;src_tab&gt; assigning &lt;line&gt;.
      if does_line_fit_filter( i_line = &lt;line&gt; i_filter = lt_filter ) = abap_true.
        if ld_dst-&gt;kind = &apos;S&apos;. &quot; Structure
          e_data = &lt;line&gt;.
          exit. &quot; Only first line goes to structure and then exits
        else. &quot; Table
          append &lt;line&gt; to &lt;tmp_tab&gt;.
        endif.
      endif.
    endloop.

    if ld_dst-&gt;kind = &apos;T&apos;.
      e_data = &lt;tmp_tab&gt;.
      free r_data_tab.
    endif.

  endif.

  if e_data is initial.
    zcx_mockup_loader_error=&gt;raise( msg = &apos;No data returned&apos; code = &apos;04&apos; ). &quot;#EC NOTEXT
  endif.

endmethod.</source>
  </method>
  <method CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="_STORE" VERSION="1" LANGU="E" DESCRIPT="Save data to store HELPER" EXPOSURE="0" STATE="1" EDITORDER="10 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="_STORE" SCONAME="I_NAME" VERSION="1" LANGU="E" DESCRIPT="Store place label" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CHAR40"/>
   <parameter CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="_STORE" SCONAME="I_DATA_REF" VERSION="1" LANGU="E" DESCRIPT="Data to store" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="DATA"/>
   <parameter CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="_STORE" SCONAME="I_TABKEY" VERSION="1" LANGU="E" DESCRIPT="Table key for filtering" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_COMPNAME" PAROPTIONL="X"/>
   <exception CLSNAME="ZCL_MOCKUP_LOADER" CMPNAME="_STORE" SCONAME="ZCX_MOCKUP_LOADER_ERROR" VERSION="1" LANGU="E" MTDTYPE="0" EDITORDER="1 "/>
   <source>method _store.
  data:
        l_store       type ty_store,
        lo_type       type ref to cl_abap_typedescr,
        lo_tab_type   type ref to cl_abap_tabledescr,
        lo_str_type   type ref to cl_abap_structdescr.

  &quot; Check if tabkey exists
  if i_tabkey is not initial.
    lo_type = cl_abap_typedescr=&gt;describe_by_data_ref( i_data_ref ).
    if lo_type-&gt;kind &lt;&gt; &apos;T&apos;. &quot; Not table ?
      zcx_mockup_loader_error=&gt;raise( msg = &apos;Tabkey is relevant for tables only&apos; code = &apos;TO&apos; ). &quot;#EC NOTEXT
    endif.

    lo_tab_type ?= lo_type.
    lo_str_type ?= lo_tab_type-&gt;get_table_line_type( ).

    read table lo_str_type-&gt;components with key name = i_tabkey transporting no fields.
    if sy-subrc &lt;&gt; 0.
      zcx_mockup_loader_error=&gt;raise( msg = &apos;Tabkey field not found&apos; code = &apos;FM&apos; ). &quot;#EC NOTEXT
    endif.
  endif.

  &quot; Store data
  l_store-name   = i_name.
  l_store-tabkey = i_tabkey.
  l_store-data   = i_data_ref.

  me-&gt;purge( i_name ).
  append l_store to me-&gt;at_store.

endmethod.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCX_MOCKUP_LOADER_ERROR" VERSION="1" LANGU="E" DESCRIPT="Exception class for mockup loader" CATEGORY="40" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" RSTAT="K" CLSBCCAT="00" MSG_ID="SY" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk" REFCLSNAME="CX_STATIC_CHECK">
  <implementing CLSNAME="ZCX_MOCKUP_LOADER_ERROR" REFCLSNAME="IF_T100_MESSAGE" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="1 "/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <attribute CLSNAME="ZCX_MOCKUP_LOADER_ERROR" CMPNAME="CODE" VERSION="1" LANGU="E" DESCRIPT="Tech code for unit tests" EXPOSURE="2" STATE="1" EDITORDER="4 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="CHAR2" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCX_MOCKUP_LOADER_ERROR" CMPNAME="METHNAME" VERSION="1" LANGU="E" DESCRIPT="Method where exception happened" EXPOSURE="2" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SCX_ATTRNAME" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCX_MOCKUP_LOADER_ERROR" CMPNAME="MSG" VERSION="1" LANGU="E" DESCRIPT="Text description" EXPOSURE="2" STATE="1" EDITORDER="3 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SCX_ATTRNAME" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCX_MOCKUP_LOADER_ERROR" CMPNAME="ZCX_MOCKUP_LOADER_ERROR" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="2" ATTEXPVIRT="0" TYPTYPE="4" SRCROW1="12 " SRCCOLUMN1="4 " SRCROW2="19 " SRCCOLUMN2="33 " LOCKED="X" TYPESRC_LENG="323 " TYPESRC="begin of ZCX_MOCKUP_LOADER_ERROR,
      msgid type symsgid value &apos;SY&apos;,
      msgno type symsgno value &apos;499&apos;,
      attr1 type scx_attrname value &apos;METHNAME&apos;,
      attr2 type scx_attrname value &apos;MSG&apos;,
      attr3 type scx_attrname value &apos;&apos;,
      attr4 type scx_attrname value &apos;&apos;,
    end of ZCX_MOCKUP_LOADER_ERROR
"/>
  <inheritance CLSNAME="ZCX_MOCKUP_LOADER_ERROR" REFCLSNAME="CX_STATIC_CHECK" VERSION="1" STATE="1"/>
  <method CLSNAME="ZCX_MOCKUP_LOADER_ERROR" CMPNAME="RAISE" VERSION="1" LANGU="E" DESCRIPT="Raise the exception" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCX_MOCKUP_LOADER_ERROR" CMPNAME="RAISE" SCONAME="MSG" VERSION="1" LANGU="E" DESCRIPT="Error description" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
   <parameter CLSNAME="ZCX_MOCKUP_LOADER_ERROR" CMPNAME="RAISE" SCONAME="CODE" VERSION="1" LANGU="E" DESCRIPT="Error code" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CHAR2" PAROPTIONL="X"/>
   <exception CLSNAME="ZCX_MOCKUP_LOADER_ERROR" CMPNAME="RAISE" SCONAME="ZCX_MOCKUP_LOADER_ERROR" VERSION="1" LANGU="E" DESCRIPT="Exception class for mockup loader" MTDTYPE="0" EDITORDER="1 "/>
   <source>method RAISE.
  data:
        l_methname  type string,
        sys_call    type sys_calls,
        sys_stack   type sys_callst.

  &quot; Get stack information
  call function &apos;SYSTEM_CALLSTACK&apos;
    exporting max_level    = 2
    importing et_callstack = sys_stack.

  read table sys_stack into sys_call index 2.
  l_methname = sys_call-eventname &amp;&amp; &apos;():&apos;.

  raise exception type zcx_mockup_loader_error
    exporting
      methname = l_methname
      msg      = msg
      code     = code.

endmethod.</source>
  </method>
 </CLAS>
 <PROG NAME="ZMOCKUP_LOADER_EXAMPLE" VARCL="X" SUBC="1" APPL="*" RSTAT="T" RMAND="100" RLOAD="E" FIXPT="X" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="Mockup loader example program" LENGTH="29 "/>
   </language>
  </textPool>
  <source>*/--------------------------------------------------------------------------------\
*| This file is part of Mockup loader                                             |
*|                                                                                |
*| The MIT License (MIT)                                                          |
*|                                                                                |
*| Copyright (c) 2015 SBCG Team (www.sbcg.com.ua), Alexander Tsybulsky            |
*|                                                                                |
*| Permission is hereby granted, free of charge, to any person obtaining a copy   |
*| of this software and associated documentation files (the &quot;Software&quot;), to deal  |
*| in the Software without restriction, including without limitation the rights   |
*| to use, copy, modify, merge, publish, distribute, sublicense, and/or sell      |
*| copies of the Software, and to permit persons to whom the Software is          |
*| furnished to do so, subject to the following conditions:                       |
*|                                                                                |
*| The above copyright notice and this permission notice shall be included in all |
*| copies or substantial portions of the Software.                                |
*|                                                                                |
*| THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR     |
*| IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,       |
*| FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE    |
*| AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER         |
*| LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,  |
*| OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  |
*| SOFTWARE.                                                                      |
*\--------------------------------------------------------------------------------/
*/--------------------------------------------------------------------------------\
*| project homepage: https://github.com/sbcgua/mockup_loader                      |
*\--------------------------------------------------------------------------------/

report zmockup_loader_example.

**********************************************************************
* SINGLETON SETTINGS CLASS (a sample way to get test env indicator)
**********************************************************************
class lcl_context definition final create private.

  public section.
    data a_carrid  type sflight-carrid read-only.       &quot; Indicates execution in test environment
    data a_testenv type abap_bool read-only.

    class-methods get_instance
      returning value(ro_instance) type ref to lcl_context.

    methods set_carrid
      importing i_carrid type sflight-carrid.

  private section.
    class-data go_instance type ref to lcl_context.     &quot; Some settings for the production code

endclass.  &quot; lcl_context

class lcl_context implementation.
  method get_instance. &quot; Get sinleton instance
    if go_instance is not bound.
      create object go_instance.
    endif.
    ro_instance = go_instance.
  endmethod.

  method set_carrid. &quot; Setup context for production environment
    clear: me-&gt;a_carrid, me-&gt;a_testenv.
    me-&gt;a_carrid = i_carrid.
    if i_carrid = &apos;ZZZ&apos;. &quot; Special test env airline - non existing !
      me-&gt;a_testenv = abap_true.
    endif.
  endmethod.

endclass.  &quot; lcl_context

**********************************************************************
* SOME BUSINESS LOGIC CLASS - the object to test
**********************************************************************
class lcl_main_logic definition final create public.

  public section.
    methods constructor.
    methods get_price
      importing
        i_connid type sflight-connid
        i_date   type sflight-fldate
      returning value(r_price) type sflight-price
      exceptions not_found.

  private section.
    data o_context type ref to lcl_context.

endclass.  &quot; lcl_main_logic

class lcl_main_logic implementation.
  method constructor.
    o_context = lcl_context=&gt;get_instance( ). &quot; Get context
  endmethod.   &quot;constructor

  method get_price. &quot; Get price of the connection in the context airline
    data ls_flight type sflight.

    if o_context-&gt;a_testenv = abap_false. &quot; Production env
      select single price into corresponding fields of ls_flight
        from sflight
        where carrid = o_context-&gt;a_carrid
        and   connid = i_connid
        and   fldate = i_date.
    else.                                  &quot; Test env
      zcl_mockup_loader=&gt;retrieve( exporting i_name = &apos;SFLIGHT&apos;  i_sift = i_connid
                                   importing e_data = ls_flight  exceptions others = 4 ).
    endif.

    if sy-subrc is not initial. &quot; Selection error ?
      raise not_found.
    endif.

    r_price = ls_flight-price.

  endmethod.   &quot;get_price
endclass.  &quot; lcl_main_logic

**********************************************************************
* TEST CLASS
**********************************************************************
class lcl_test definition for testing duration short
  inheriting from cl_aunit_assert  risk level harmless.

  public section.
    types:
      begin of ty_testcase, &quot; test case structure
        testid   type i,
        type     type char1,
        connid   type sflight-connid,
        result   type sflight-price,
        msg      type string,
      end of ty_testcase.

  private section.
    data o    type ref to lcl_main_logic.    &quot; Class being tested
    data o_ml type ref to zcl_mockup_loader. &quot; Mockup loader

    class-methods: class_setup.
    methods: setup.
    methods: get_price for testing.

endclass.   &quot;lcl_test

class lcl_test implementation.
  method class_setup. &quot; Set mockup source -&gt; workstation file
    zcl_mockup_loader=&gt;class_set_source( i_type = &apos;FILE&apos; i_path = &apos;c:\sap\example.zip&apos; ).
    zcl_mockup_loader=&gt;class_set_params( i_amt_format = &apos; ,&apos; ).
  endmethod.

  method setup. &quot; Initialize instances
    data lo_context type ref to lcl_context.
    data lo_ex      type ref to zcx_mockup_loader_error.

    lo_context = lcl_context=&gt;get_instance( ).
    lo_context-&gt;set_carrid( &apos;ZZZ&apos; ). &quot; Test env airline

    create object o.

    try.
      o_ml = zcl_mockup_loader=&gt;get_instance( ).
    catch zcx_mockup_loader_error into lo_ex.
      fail( lo_ex-&gt;get_text( ) ).
    endtry.

  endmethod.

  method get_price.
    data lt_testcases type table of ty_testcase.
    data ls_case      type ty_testcase.
    data lo_ex        type ref to zcx_mockup_loader_error.
    data l_result     type sflight-price.

    try.
      &quot; Load test cases index for local usage
      o_ml-&gt;load_data( exporting i_obj       = &apos;EXAMPLE/testcases&apos;
                       importing e_container = lt_testcases ).

      &quot; Load and store flights table
      o_ml-&gt;load_and_store( i_obj    = &apos;EXAMPLE/sflight&apos;
                            i_name   = &apos;SFLIGHT&apos;
                            i_strict = abap_false
                            i_tabkey = &apos;CONNID&apos;
                            i_type   = &apos;FLIGHTTAB&apos; ).

    catch zcx_mockup_loader_error into lo_ex.
      fail( lo_ex-&gt;get_text( ) ).
    endtry.

    loop at lt_testcases into ls_case. &quot; Loop through test catalog and run tests
      o-&gt;get_price( exporting i_connid = ls_case-connid
                              i_date   = &apos;20150101&apos;
                    receiving r_price  = l_result
                    exceptions others = 4 ).

      if ls_case-type = &apos;+&apos;. &quot; Positive test
        assert_subrc(  act = sy-subrc  exp = 0
                       msg = |[{ ls_case-testid }] { ls_case-msg }| ).
        assert_equals( act = l_result  exp = ls_case-result
                       msg = |[{ ls_case-testid }] { ls_case-msg }| ).

      else. &quot;&apos;-&apos;             &quot; Negative test
        assert_subrc(  act = sy-subrc  exp = 4
                       msg = |[{ ls_case-testid }] { ls_case-msg }| ).
      endif.

    endloop.

  endmethod.

endclass.   &quot;lcl_test</source>
 </PROG>
 <PROG NAME="ZMOCKUP_LOADER_SWITCH_SOURCE" VARCL="X" SUBC="1" APPL="*" RMAND="100" RLOAD="E" FIXPT="X" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="Switch mockup source via SET/GET params" LENGTH="39 "/>
   </language>
  </textPool>
  <source>*/--------------------------------------------------------------------------------\
*| This file is part of Mockup loader                                             |
*|                                                                                |
*| The MIT License (MIT)                                                          |
*|                                                                                |
*| Copyright (c) 2015 SBCG Team (www.sbcg.com.ua), Alexander Tsybulsky            |
*|                                                                                |
*| Permission is hereby granted, free of charge, to any person obtaining a copy   |
*| of this software and associated documentation files (the &quot;Software&quot;), to deal  |
*| in the Software without restriction, including without limitation the rights   |
*| to use, copy, modify, merge, publish, distribute, sublicense, and/or sell      |
*| copies of the Software, and to permit persons to whom the Software is          |
*| furnished to do so, subject to the following conditions:                       |
*|                                                                                |
*| The above copyright notice and this permission notice shall be included in all |
*| copies or substantial portions of the Software.                                |
*|                                                                                |
*| THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR     |
*| IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,       |
*| FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE    |
*| AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER         |
*| LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,  |
*| OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  |
*| SOFTWARE.                                                                      |
*\--------------------------------------------------------------------------------/
*/--------------------------------------------------------------------------------\
*| CONTRIBUTORS                                                                   |
*|--------------------------------------------------------------------------------|
*| Leading developers : Alexander Tsybulsky (atsybulsky@sbcg.com.ua)              |
*|                      Svetlana Shlapak    (sshlapak@sbcg.com.ua)                |
*| Testing and ideas:   Bohdan Petruschak   (b.petrushchak@sbcg.com.ua)           |
*|--------------------------------------------------------------------------------|
*| project homepage: https://github.com/sbcgua/mockup_loader                      |
*\--------------------------------------------------------------------------------/


report zmockup_loader_switch_source.
tables sscrfields.

*&amp;---------------------------------------------------------------------*
*&amp;      Selection screen
*&amp;---------------------------------------------------------------------*
selection-screen begin of block b1 with frame title txt_b1.
selection-screen begin of line.
parameters p_undef type char1 radiobutton group gr1 user-command gr1.
selection-screen comment (10) txt_und  for field p_undef.
selection-screen end of line.

selection-screen begin of line.
parameters p_mime type char1 radiobutton group gr1.
selection-screen comment (10) txt_mime for field p_mime.
selection-screen end of line.

selection-screen begin of line.
parameters p_file type char1 radiobutton group gr1.
selection-screen comment (10) txt_file for field p_file.
selection-screen end of line.

selection-screen begin of line.
selection-screen comment (15) txt_fp for field p_file.
parameters p_fpath type char128.
selection-screen end of line.

selection-screen begin of line.
selection-screen comment (15) txt_mp for field p_file .
parameters: p_mpath type char40.
selection-screen end of line.
selection-screen end of block b1.

selection-screen: function key 1.


*&amp;---------------------------------------------------------------------*
*&amp;      Screen events
*&amp;---------------------------------------------------------------------*
initialization.

  txt_b1   = &apos;Source type (switch saves parameter immediately)&apos;. &quot;#EC NOTEXT
  txt_und  = &apos;Undefined&apos;.                                   &quot;#EC NOTEXT
  txt_mime = &apos;MIME&apos;.                                        &quot;#EC NOTEXT
  txt_file = &apos;FILE&apos;.                                        &quot;#EC NOTEXT
  txt_fp   = &apos;File path&apos;.                                   &quot;#EC NOTEXT
  txt_mp   = &apos;MIME object&apos;.                                 &quot;#EC NOTEXT

  sscrfields-functxt_01 = &apos;Get SU3 value&apos;.                  &quot;#EC NOTEXT

  perform get_stype.

at selection-screen output.
  perform insert_into_excl(rsdbrunt) using &apos;ONLI&apos;. &quot;exclude Execute button
  perform set_stype.

at selection-screen on radiobutton group gr1.
  perform set_stype.

at selection-screen on value-request for p_fpath.
  perform f4_file_path changing p_fpath.

at selection-screen on value-request for p_mpath.
  perform f4_mime_path changing p_mpath.

at selection-screen on p_fpath.
  if p_file is not initial.
    set parameter id &apos;ZMOCKUP_LOADER_SPATH&apos; field p_fpath.
  endif.

at selection-screen on p_mpath.
  if p_mime is not initial.
    set parameter id &apos;ZMOCKUP_LOADER_SPATH&apos; field p_mpath.
  endif.

at selection-screen.
  case sy-ucomm.
    when &apos;FC01&apos;.          &quot;Get SU3 value
    perform get_su3_value.
  endcase.

*&amp;---------------------------------------------------------------------*
*&amp;      Form  set_stype
*&amp;---------------------------------------------------------------------*
form set_stype.
  data: l_stype type char4.

  if p_file is not initial.
    l_stype = &apos;FILE&apos;.
    clear: p_mpath.

    loop at screen.
      case screen-name.
        when &apos;P_MPATH&apos; or &apos;TXT_MP&apos;.
          screen-active = 0.
        when &apos;P_FPATH&apos; or &apos;TXT_FP&apos;.
          screen-active = 1.
      endcase.
      modify screen.
    endloop.

  elseif p_mime is not initial.
    l_stype = &apos;MIME&apos;.
    clear: p_fpath.
    loop at screen.
      case screen-name.
        when &apos;P_MPATH&apos; or &apos;TXT_MP&apos;.
          screen-active = 1.
        when &apos;P_FPATH&apos; or &apos;TXT_FP&apos;.
          screen-active = 0.
      endcase.
      modify screen.
    endloop.

  elseif p_undef is not initial.
    clear l_stype.
    loop at screen.
      case screen-name.
        when &apos;P_MPATH&apos; or &apos;P_FPATH&apos; or &apos;TXT_FP&apos; or &apos;TXT_MP&apos;.
          screen-active = 0.
      endcase.
      modify screen.
    endloop.
  endif.

  set parameter id &apos;ZMOCKUP_LOADER_STYPE&apos; field l_stype.

endform.                    &quot;set_stype

*&amp;---------------------------------------------------------------------*
*&amp;      Form  get_stype
*&amp;---------------------------------------------------------------------*
form get_stype.
  data: l_stype type char4,
        l_spath type char128.

  get parameter id &apos;ZMOCKUP_LOADER_STYPE&apos; field l_stype.
  get parameter id &apos;ZMOCKUP_LOADER_SPATH&apos; field l_spath.
  clear: p_fpath, p_mpath.

  case l_stype.
    when &apos;FILE&apos;.
      p_file  = &apos;X&apos;.
      p_fpath = l_spath.
    when &apos;MIME&apos;.
      p_mime  = &apos;X&apos;.
      p_mpath = l_spath.
    when others.
      p_undef = &apos;X&apos;.
  endcase.
endform.                    &quot;get_stype

*&amp;---------------------------------------------------------------------*
*&amp;      Form  set_file_path
*&amp;---------------------------------------------------------------------*
form f4_file_path changing c_path.
  data: l_path type localfile.

  call function &apos;F4_FILENAME&apos;
    importing
      file_name = l_path.

  c_path = l_path.
  set parameter id &apos;ZMOCKUP_LOADER_SPATH&apos; field l_path.
endform.                    &quot;set_file_path

*&amp;---------------------------------------------------------------------*
*&amp;      Form  set_mime_path
*&amp;---------------------------------------------------------------------*
form f4_mime_path changing c_path.
  types:
    begin of t_data,
      objid type wwwdata-objid,
      text  type wwwdata-text,
    end of t_data.

  data:
        ls_return type ddshretval,
        lt_data   type table of t_data,
        lt_return type table of ddshretval.

  select distinct objid text from wwwdata
    into corresponding fields of table lt_data
    where relid = &apos;MI&apos;
    and   objid like &apos;Z%&apos;
    order by objid.

  call function &apos;F4IF_INT_TABLE_VALUE_REQUEST&apos;
    exporting
      retfield        = &apos;OBJID&apos;
      dynprofield     = &apos;P_MPATH&apos;
      value_org       = &apos;S&apos;
    tables
      value_tab       = lt_data
      return_tab      = lt_return
    exceptions
      parameter_error = 1
      no_values_found = 2
      others          = 3.

  if sy-subrc is not initial.
    message id sy-msgid type sy-msgty number sy-msgno
            with sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
  endif.

  read table lt_return into ls_return index 1.
  p_mpath = ls_return-fieldval.
  set parameter id &apos;ZMOCKUP_LOADER_SPATH&apos; field p_mpath.
endform.                    &quot;set_file_path

*&amp;---------------------------------------------------------------------*
*&amp;      Form  get_su3_value
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
form get_su3_value.
  data l_param type usr05-parva.

  call function &apos;G_GET_USER_PARAMETER&apos;
    exporting parameter_id    = &apos;ZMOCKUP_LOADER_SPATH&apos;
    importing parameter_value = l_param.

  if p_file is not initial.
    p_fpath = l_param.
    set parameter id &apos;ZMOCKUP_LOADER_SPATH&apos; field l_param.
  elseif p_mime is not initial.
    p_mpath = l_param.
    set parameter id &apos;ZMOCKUP_LOADER_SPATH&apos; field l_param.
  endif.
endform.                    &quot;get_su3_value</source>
 </PROG>
 <TRAN TCODE="ZMOCKUP_LOADER_SWSRC" PGMNA="ZMOCKUP_LOADER_SWITCH_SOURCE" DYPNO="1000" CINFO="80">
  <tstct SPRSL="E" TCODE="ZMOCKUP_LOADER_SWSRC" TTEXT="Switch mockup source temporarily"/>
  <tstcc TCODE="ZMOCKUP_LOADER_SWSRC" S_WEBGUI="1" S_WIN32="X" S_PLATIN="X"/>
 </TRAN>
 <PARA PARAMID="ZMOCKUP_LOADER_SPATH">
  <parat PARAMID="ZMOCKUP_LOADER_SPATH" SPRACHE="E" PARTEXT="Mockup loader source path"/>
 </PARA>
 <PARA PARAMID="ZMOCKUP_LOADER_STYPE">
  <parat PARAMID="ZMOCKUP_LOADER_STYPE" SPRACHE="E" PARTEXT="Mockup loader source type"/>
 </PARA>
</nugget>
